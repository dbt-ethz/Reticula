<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>mola.utils_vertex API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mola.utils_vertex</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import division

#!/usr/bin/env python
# -*- coding: utf-8 -*-
__author__     = [&#39;Benjamin Dillenburger&#39;,&#39;Demetris Shammas&#39;,&#39;Mathias Bernhard&#39;]
__copyright__  = &#39;Copyright 2019 / Digital Building Technologies DBT / ETH Zurich&#39;
__license__    = &#39;MIT License&#39;
__email__      = [&#39;&lt;dbt@arch.ethz.ch&gt;&#39;]

import math
from mola.core_vertex import Vertex
from mola import utils_math

def vertex_add(v1,v2):
    &#34;&#34;&#34;
    adds the position vector of v2 to the position vector of v1
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)

def vertex_subtract(v1,v2):
    &#34;&#34;&#34;
    subtracts the position vector of v2 from the position vector of v1
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)

def vertex_scale(v,factor):
    &#34;&#34;&#34;
    scales the position vector of a Vertex by a factor (multiplication)
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v.x * factor, v.y * factor, v.z * factor)

def vertex_divide(v,factor):
    &#34;&#34;&#34;
    scales the position vector of a Vertex by a factor (division)
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v.x / factor, v.y / factor, v.z / factor)

def vertex_center(v1,v2):
    &#34;&#34;&#34;
    Returns the center of a line defined by two vertices.

    Arguments:
    ----------
    v1, v2 : mola.Vertex
        start and end points of the line

    Returns:
    --------
    mola.Vertex
        the center point of the line
    &#34;&#34;&#34;

    return Vertex((v1.x+v2.x)/2,(v1.y+v2.y)/2,(v1.z+v2.z)/2)

def vertex_unitize(v):
    &#34;&#34;&#34;
    returns a Vertex of the same direction
    and of unit length 1
    &#34;&#34;&#34;
    l = vertex_length(v)
    if l == 0:
        return v
    return vertex_scale(v,1/l)

def vertex_angle(v1,v2):
    a = vertex_unitize(v1)
    b = vertex_unitize(v2)
    f = vertex_dot(a, b)
    f = min(1, max(-1, f))
    return math.acos(f)

def vertex_angle_triangle(vPrevious,v,vNext):
    #law of cosines
    vvn = vertex_distance(v, vNext)
    vvp = vertex_distance(vPrevious, v)
    vnvp = vertex_distance(vNext, vPrevious)
    return math.acos((vvn * vvn + vvp * vvp - vnvp * vnvp) / (2 * vvn * vvp))

def vertex_length(v):
    &#34;&#34;&#34;
    returns the length of the position vector of a Vertex,
    the distance from the origin (0,0,0).
    &#34;&#34;&#34;
    return math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)

def vertex_dot(v1,v2):
    &#34;&#34;&#34;
    returns the dot product of v1 and v2.
    &#34;&#34;&#34;
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z

def vertex_cross(v1,v2):
    &#34;&#34;&#34;
    returns the cross product of v1 and v2 as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v1.y * v2.z - v2.y * v1.z, v1.z * v2.x - v2.z * v1.x, v1.x * v2.y - v2.x * v1.y)

def vertex_distance(v1,v2):
    &#34;&#34;&#34;
    returns the distance between v1 and v2.
    &#34;&#34;&#34;
    dX = v2.x - v1.x
    dY = v2.y - v1.y
    dZ = v2.z - v1.z
    return math.sqrt(dX*dX+dY*dY+dZ*dZ)

def vertex_between_rel(v1, v2, factor):
    &#34;&#34;&#34;
    finds a position vector between v1 and v2 by a factor (0.0 to 1.0 corresponds to v1 to v2)
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex((v2.x - v1.x) * factor + v1.x, (v2.y - v1.y) * factor + v1.y, (v2.z - v1.z) * factor + v1.z)

def vertex_between_abs(v1, v2, dis):
    &#34;&#34;&#34;
    finds a position vector between v1 and v2 by an absolute distance value from v1
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    d = vertex_distance(v1,v2)
    return vertex_between_rel(v1, v2, dis / d)

def vertex_rotate_2D_90(vertex):
    return Vertex(-vertex.y, vertex.x, vertex.z)


def vertex_offset_line(v1, v2, offset):
    v = vertex_subtract(v2, v1)
    v = vertex_unitize(v)
    v = vertex_scale(v,offset)
    t = v.x
    v.x = -v.y
    v.y = t
    v.z = 0
    return Vertex(vertex_add(v1, v), vertex_add(v2, v))

def vertex_offset_point(v1, v2, v3, offset1, offset2):
    line1 = vertex_offset_line(v1, v2, offset1)
    line2 = vertex_offset_line(v2, v3, offset2)
    return vertex_line_line_intersection(line1.x,line1.y,line2.x,line2.y)

def vertex_line_line_intersection(a,b,c,d):
    &#34;&#34;&#34;
    Returns the intersection of two lines in 2D as a new Vertex.

    Arguments:
    ----------
    a,b,c,d: mola.Vertex
             a,b are the endpoints of line1
             c,d are the endpoints of line2
    &#34;&#34;&#34;
    deltaABX = b.x - a.x
    deltaABY = b.y - a.y
    deltaDCX = d.x - c.x
    deltaDCY = d.y - c.y
    denominator = deltaABX * deltaDCY - deltaABY * deltaDCX
    if denominator == 0:
        return None
    numerator = (a.y - c.y) * deltaDCX - (a.x - c.x) * deltaDCY
    r = numerator / denominator
    x = a.x + r * deltaABX
    y = a.y + r * deltaABY
    return Vertex(x,y,0)


&#34;&#34;&#34;// VERTICES LIST //&#34;&#34;&#34;

def vertices_list_normal(vertices):
    &#34;&#34;&#34;
    Returns the normal of a triangle defined by 3 vertices.
    The normal is a vector of length 1 perpendicular to the plane of the triangle.

    Arguments:
    ----------
    vertices : list
        the list of vertices get the normal from (first 3 will be used)
    &#34;&#34;&#34;
    return normalFromTriangle(vertices[0], vertices[1], vertices[2])

def vertices_list_area(vertices):
    &#34;&#34;&#34;
    Returns the area of a face from a list of 3 or 4 vertices
    &#34;&#34;&#34;
    if len(vertices) == 3:
        return triangle_area(vertices[0],vertices[1],vertices[2])
    # could be made generic for n-gons, triangle fan?
    elif len(vertices) == 4:
        a1 = triangle_area(vertices[0], vertices[1], vertices[2])
        a2 = triangle_area(vertices[2], vertices[3], vertices[0])
        return a1 + a2

def vertices_list_center(vertices):
    &#34;&#34;&#34;
    Returns the center point (type Vertex) of a list of vertices.
    Note: not the center of gravity, just the average of the vertices.

    Arguments:
    ----------
    vertices : list of mola.Vertex
            The list of vertices to be measured
    &#34;&#34;&#34;
    n = len(vertices)
    cx = sum([v.x for v in vertices]) / n
    cy = sum([v.y for v in vertices]) / n
    cz = sum([v.z for v in vertices]) / n
    return Vertex(cx,cy,cz)


&#34;&#34;&#34;// TRIANGLE //&#34;&#34;&#34;

def triangle_area(v1,v2,v3):
    &#34;&#34;&#34;
    Returns the area of the triangle from 3 vertices

    Arguments:
    ----------
    v1, v2, v3 : mola.Vertex
        vertices of the triangle
    &#34;&#34;&#34;
    return triangle_coords_area(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z)

def triangle_normal(v1,v2,v3):
    &#34;&#34;&#34;
    Returns the normal of a triangle defined by 3 vertices.
    The normal is a vector of length 1 perpendicular to the plane of the triangle.

    Arguments:
    ----------
    v1, v2, v3 : mola.Vertex
        the vertices get the normal from
    &#34;&#34;&#34;
    v = v2-v1
    u = v3-v1
    crossProduct=vertex_cross(v, u)
    return vertex_unitize(crossProduct)

def triangle_coords_area(xa, ya, za, xb, yb, zb, xc, yc, zc):
    &#34;&#34;&#34;
    Returns the area of the triangle from 9 coordinates

    Arguments:
    ----------
    xa, ya, za : float
        coordinates of vertex a
    xb, yb, zb : float
        coordinates of vertex b
    xc, yc, zc : float
        coordinates of vertex c
    &#34;&#34;&#34;
    return 0.5 * math.sqrt(math.pow(utils_math.math_determinant(xa, xb, xc, ya, yb, yc, 1, 1, 1), 2) + math.pow(utils_math.math_determinant(ya, yb, yc, za, zb, zc, 1, 1, 1), 2) + math.pow(utils_math.math_determinant(za, zb, zc, xa, xb, xc, 1, 1, 1), 2))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mola.utils_vertex.triangle_area"><code class="name flex">
<span>def <span class="ident">triangle_area</span></span>(<span>v1, v2, v3)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the area of the triangle from 3 vertices</p>
<h2 id="arguments">Arguments:</h2>
<p>v1, v2, v3 : mola.Vertex
vertices of the triangle</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_area(v1,v2,v3):
    &#34;&#34;&#34;
    Returns the area of the triangle from 3 vertices

    Arguments:
    ----------
    v1, v2, v3 : mola.Vertex
        vertices of the triangle
    &#34;&#34;&#34;
    return triangle_coords_area(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.triangle_coords_area"><code class="name flex">
<span>def <span class="ident">triangle_coords_area</span></span>(<span>xa, ya, za, xb, yb, zb, xc, yc, zc)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the area of the triangle from 9 coordinates</p>
<h2 id="arguments">Arguments:</h2>
<p>xa, ya, za : float
coordinates of vertex a
xb, yb, zb : float
coordinates of vertex b
xc, yc, zc : float
coordinates of vertex c</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_coords_area(xa, ya, za, xb, yb, zb, xc, yc, zc):
    &#34;&#34;&#34;
    Returns the area of the triangle from 9 coordinates

    Arguments:
    ----------
    xa, ya, za : float
        coordinates of vertex a
    xb, yb, zb : float
        coordinates of vertex b
    xc, yc, zc : float
        coordinates of vertex c
    &#34;&#34;&#34;
    return 0.5 * math.sqrt(math.pow(utils_math.math_determinant(xa, xb, xc, ya, yb, yc, 1, 1, 1), 2) + math.pow(utils_math.math_determinant(ya, yb, yc, za, zb, zc, 1, 1, 1), 2) + math.pow(utils_math.math_determinant(za, zb, zc, xa, xb, xc, 1, 1, 1), 2))</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.triangle_normal"><code class="name flex">
<span>def <span class="ident">triangle_normal</span></span>(<span>v1, v2, v3)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the normal of a triangle defined by 3 vertices.
The normal is a vector of length 1 perpendicular to the plane of the triangle.</p>
<h2 id="arguments">Arguments:</h2>
<p>v1, v2, v3 : mola.Vertex
the vertices get the normal from</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_normal(v1,v2,v3):
    &#34;&#34;&#34;
    Returns the normal of a triangle defined by 3 vertices.
    The normal is a vector of length 1 perpendicular to the plane of the triangle.

    Arguments:
    ----------
    v1, v2, v3 : mola.Vertex
        the vertices get the normal from
    &#34;&#34;&#34;
    v = v2-v1
    u = v3-v1
    crossProduct=vertex_cross(v, u)
    return vertex_unitize(crossProduct)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_add"><code class="name flex">
<span>def <span class="ident">vertex_add</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>adds the position vector of v2 to the position vector of v1
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_add(v1,v2):
    &#34;&#34;&#34;
    adds the position vector of v2 to the position vector of v1
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_angle"><code class="name flex">
<span>def <span class="ident">vertex_angle</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_angle(v1,v2):
    a = vertex_unitize(v1)
    b = vertex_unitize(v2)
    f = vertex_dot(a, b)
    f = min(1, max(-1, f))
    return math.acos(f)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_angle_triangle"><code class="name flex">
<span>def <span class="ident">vertex_angle_triangle</span></span>(<span>vPrevious, v, vNext)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_angle_triangle(vPrevious,v,vNext):
    #law of cosines
    vvn = vertex_distance(v, vNext)
    vvp = vertex_distance(vPrevious, v)
    vnvp = vertex_distance(vNext, vPrevious)
    return math.acos((vvn * vvn + vvp * vvp - vnvp * vnvp) / (2 * vvn * vvp))</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_between_abs"><code class="name flex">
<span>def <span class="ident">vertex_between_abs</span></span>(<span>v1, v2, dis)</span>
</code></dt>
<dd>
<section class="desc"><p>finds a position vector between v1 and v2 by an absolute distance value from v1
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_between_abs(v1, v2, dis):
    &#34;&#34;&#34;
    finds a position vector between v1 and v2 by an absolute distance value from v1
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    d = vertex_distance(v1,v2)
    return vertex_between_rel(v1, v2, dis / d)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_between_rel"><code class="name flex">
<span>def <span class="ident">vertex_between_rel</span></span>(<span>v1, v2, factor)</span>
</code></dt>
<dd>
<section class="desc"><p>finds a position vector between v1 and v2 by a factor (0.0 to 1.0 corresponds to v1 to v2)
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_between_rel(v1, v2, factor):
    &#34;&#34;&#34;
    finds a position vector between v1 and v2 by a factor (0.0 to 1.0 corresponds to v1 to v2)
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex((v2.x - v1.x) * factor + v1.x, (v2.y - v1.y) * factor + v1.y, (v2.z - v1.z) * factor + v1.z)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_center"><code class="name flex">
<span>def <span class="ident">vertex_center</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the center of a line defined by two vertices.</p>
<h2 id="arguments">Arguments:</h2>
<p>v1, v2 : mola.Vertex
start and end points of the line</p>
<h2 id="returns">Returns:</h2>
<p>mola.Vertex
the center point of the line</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_center(v1,v2):
    &#34;&#34;&#34;
    Returns the center of a line defined by two vertices.

    Arguments:
    ----------
    v1, v2 : mola.Vertex
        start and end points of the line

    Returns:
    --------
    mola.Vertex
        the center point of the line
    &#34;&#34;&#34;

    return Vertex((v1.x+v2.x)/2,(v1.y+v2.y)/2,(v1.z+v2.z)/2)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_cross"><code class="name flex">
<span>def <span class="ident">vertex_cross</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the cross product of v1 and v2 as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_cross(v1,v2):
    &#34;&#34;&#34;
    returns the cross product of v1 and v2 as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v1.y * v2.z - v2.y * v1.z, v1.z * v2.x - v2.z * v1.x, v1.x * v2.y - v2.x * v1.y)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_distance"><code class="name flex">
<span>def <span class="ident">vertex_distance</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the distance between v1 and v2.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_distance(v1,v2):
    &#34;&#34;&#34;
    returns the distance between v1 and v2.
    &#34;&#34;&#34;
    dX = v2.x - v1.x
    dY = v2.y - v1.y
    dZ = v2.z - v1.z
    return math.sqrt(dX*dX+dY*dY+dZ*dZ)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_divide"><code class="name flex">
<span>def <span class="ident">vertex_divide</span></span>(<span>v, factor)</span>
</code></dt>
<dd>
<section class="desc"><p>scales the position vector of a Vertex by a factor (division)
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_divide(v,factor):
    &#34;&#34;&#34;
    scales the position vector of a Vertex by a factor (division)
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v.x / factor, v.y / factor, v.z / factor)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_dot"><code class="name flex">
<span>def <span class="ident">vertex_dot</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the dot product of v1 and v2.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_dot(v1,v2):
    &#34;&#34;&#34;
    returns the dot product of v1 and v2.
    &#34;&#34;&#34;
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_length"><code class="name flex">
<span>def <span class="ident">vertex_length</span></span>(<span>v)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the length of the position vector of a Vertex,
the distance from the origin (0,0,0).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_length(v):
    &#34;&#34;&#34;
    returns the length of the position vector of a Vertex,
    the distance from the origin (0,0,0).
    &#34;&#34;&#34;
    return math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_line_line_intersection"><code class="name flex">
<span>def <span class="ident">vertex_line_line_intersection</span></span>(<span>a, b, c, d)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the intersection of two lines in 2D as a new Vertex.</p>
<h2 id="arguments">Arguments:</h2>
<p>a,b,c,d: mola.Vertex
a,b are the endpoints of line1
c,d are the endpoints of line2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_line_line_intersection(a,b,c,d):
    &#34;&#34;&#34;
    Returns the intersection of two lines in 2D as a new Vertex.

    Arguments:
    ----------
    a,b,c,d: mola.Vertex
             a,b are the endpoints of line1
             c,d are the endpoints of line2
    &#34;&#34;&#34;
    deltaABX = b.x - a.x
    deltaABY = b.y - a.y
    deltaDCX = d.x - c.x
    deltaDCY = d.y - c.y
    denominator = deltaABX * deltaDCY - deltaABY * deltaDCX
    if denominator == 0:
        return None
    numerator = (a.y - c.y) * deltaDCX - (a.x - c.x) * deltaDCY
    r = numerator / denominator
    x = a.x + r * deltaABX
    y = a.y + r * deltaABY
    return Vertex(x,y,0)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_offset_line"><code class="name flex">
<span>def <span class="ident">vertex_offset_line</span></span>(<span>v1, v2, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_offset_line(v1, v2, offset):
    v = vertex_subtract(v2, v1)
    v = vertex_unitize(v)
    v = vertex_scale(v,offset)
    t = v.x
    v.x = -v.y
    v.y = t
    v.z = 0
    return Vertex(vertex_add(v1, v), vertex_add(v2, v))</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_offset_point"><code class="name flex">
<span>def <span class="ident">vertex_offset_point</span></span>(<span>v1, v2, v3, offset1, offset2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_offset_point(v1, v2, v3, offset1, offset2):
    line1 = vertex_offset_line(v1, v2, offset1)
    line2 = vertex_offset_line(v2, v3, offset2)
    return vertex_line_line_intersection(line1.x,line1.y,line2.x,line2.y)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_rotate_2D_90"><code class="name flex">
<span>def <span class="ident">vertex_rotate_2D_90</span></span>(<span>vertex)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_rotate_2D_90(vertex):
    return Vertex(-vertex.y, vertex.x, vertex.z)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_scale"><code class="name flex">
<span>def <span class="ident">vertex_scale</span></span>(<span>v, factor)</span>
</code></dt>
<dd>
<section class="desc"><p>scales the position vector of a Vertex by a factor (multiplication)
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_scale(v,factor):
    &#34;&#34;&#34;
    scales the position vector of a Vertex by a factor (multiplication)
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v.x * factor, v.y * factor, v.z * factor)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_subtract"><code class="name flex">
<span>def <span class="ident">vertex_subtract</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>subtracts the position vector of v2 from the position vector of v1
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_subtract(v1,v2):
    &#34;&#34;&#34;
    subtracts the position vector of v2 from the position vector of v1
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertex_unitize"><code class="name flex">
<span>def <span class="ident">vertex_unitize</span></span>(<span>v)</span>
</code></dt>
<dd>
<section class="desc"><p>returns a Vertex of the same direction
and of unit length 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_unitize(v):
    &#34;&#34;&#34;
    returns a Vertex of the same direction
    and of unit length 1
    &#34;&#34;&#34;
    l = vertex_length(v)
    if l == 0:
        return v
    return vertex_scale(v,1/l)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertices_list_area"><code class="name flex">
<span>def <span class="ident">vertices_list_area</span></span>(<span>vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the area of a face from a list of 3 or 4 vertices</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertices_list_area(vertices):
    &#34;&#34;&#34;
    Returns the area of a face from a list of 3 or 4 vertices
    &#34;&#34;&#34;
    if len(vertices) == 3:
        return triangle_area(vertices[0],vertices[1],vertices[2])
    # could be made generic for n-gons, triangle fan?
    elif len(vertices) == 4:
        a1 = triangle_area(vertices[0], vertices[1], vertices[2])
        a2 = triangle_area(vertices[2], vertices[3], vertices[0])
        return a1 + a2</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertices_list_center"><code class="name flex">
<span>def <span class="ident">vertices_list_center</span></span>(<span>vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the center point (type Vertex) of a list of vertices.
Note: not the center of gravity, just the average of the vertices.</p>
<h2 id="arguments">Arguments:</h2>
<p>vertices : list of mola.Vertex
The list of vertices to be measured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertices_list_center(vertices):
    &#34;&#34;&#34;
    Returns the center point (type Vertex) of a list of vertices.
    Note: not the center of gravity, just the average of the vertices.

    Arguments:
    ----------
    vertices : list of mola.Vertex
            The list of vertices to be measured
    &#34;&#34;&#34;
    n = len(vertices)
    cx = sum([v.x for v in vertices]) / n
    cy = sum([v.y for v in vertices]) / n
    cz = sum([v.z for v in vertices]) / n
    return Vertex(cx,cy,cz)</code></pre>
</details>
</dd>
<dt id="mola.utils_vertex.vertices_list_normal"><code class="name flex">
<span>def <span class="ident">vertices_list_normal</span></span>(<span>vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the normal of a triangle defined by 3 vertices.
The normal is a vector of length 1 perpendicular to the plane of the triangle.</p>
<h2 id="arguments">Arguments:</h2>
<p>vertices : list
the list of vertices get the normal from (first 3 will be used)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertices_list_normal(vertices):
    &#34;&#34;&#34;
    Returns the normal of a triangle defined by 3 vertices.
    The normal is a vector of length 1 perpendicular to the plane of the triangle.

    Arguments:
    ----------
    vertices : list
        the list of vertices get the normal from (first 3 will be used)
    &#34;&#34;&#34;
    return normalFromTriangle(vertices[0], vertices[1], vertices[2])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mola" href="index.html">mola</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mola.utils_vertex.triangle_area" href="#mola.utils_vertex.triangle_area">triangle_area</a></code></li>
<li><code><a title="mola.utils_vertex.triangle_coords_area" href="#mola.utils_vertex.triangle_coords_area">triangle_coords_area</a></code></li>
<li><code><a title="mola.utils_vertex.triangle_normal" href="#mola.utils_vertex.triangle_normal">triangle_normal</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_add" href="#mola.utils_vertex.vertex_add">vertex_add</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_angle" href="#mola.utils_vertex.vertex_angle">vertex_angle</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_angle_triangle" href="#mola.utils_vertex.vertex_angle_triangle">vertex_angle_triangle</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_between_abs" href="#mola.utils_vertex.vertex_between_abs">vertex_between_abs</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_between_rel" href="#mola.utils_vertex.vertex_between_rel">vertex_between_rel</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_center" href="#mola.utils_vertex.vertex_center">vertex_center</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_cross" href="#mola.utils_vertex.vertex_cross">vertex_cross</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_distance" href="#mola.utils_vertex.vertex_distance">vertex_distance</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_divide" href="#mola.utils_vertex.vertex_divide">vertex_divide</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_dot" href="#mola.utils_vertex.vertex_dot">vertex_dot</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_length" href="#mola.utils_vertex.vertex_length">vertex_length</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_line_line_intersection" href="#mola.utils_vertex.vertex_line_line_intersection">vertex_line_line_intersection</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_offset_line" href="#mola.utils_vertex.vertex_offset_line">vertex_offset_line</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_offset_point" href="#mola.utils_vertex.vertex_offset_point">vertex_offset_point</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_rotate_2D_90" href="#mola.utils_vertex.vertex_rotate_2D_90">vertex_rotate_2D_90</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_scale" href="#mola.utils_vertex.vertex_scale">vertex_scale</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_subtract" href="#mola.utils_vertex.vertex_subtract">vertex_subtract</a></code></li>
<li><code><a title="mola.utils_vertex.vertex_unitize" href="#mola.utils_vertex.vertex_unitize">vertex_unitize</a></code></li>
<li><code><a title="mola.utils_vertex.vertices_list_area" href="#mola.utils_vertex.vertices_list_area">vertices_list_area</a></code></li>
<li><code><a title="mola.utils_vertex.vertices_list_center" href="#mola.utils_vertex.vertices_list_center">vertices_list_center</a></code></li>
<li><code><a title="mola.utils_vertex.vertices_list_normal" href="#mola.utils_vertex.vertices_list_normal">vertices_list_normal</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>