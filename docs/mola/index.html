<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>mola API documentation</title>
<meta name="description" content="This is where the module documentation goes" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mola</code></h1>
</header>
<section id="section-intro">
<p>This is where the module documentation goes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This is where the module documentation goes
&#34;&#34;&#34;
from .core_box import *
from .core_edge import *
from .core_face import *
from .core_grid import *
from .core_mesh import *
from .core_vertex import *
from .graph import *
from .grid_factory import *
from .io import *
from .mesh_factory import *
from .mesh_marching_cubes import *
from .mesh_subdivision import *
from .slicer import *
from .utils_color import *
from .utils_face import *
from .utils_math import *
from .utils_mesh import *
from .utils_poly import *
from .utils_vertex import *

__all__ = [name for name in dir() if not name.startswith(&#39;_&#39;)]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="mola.colab2D" href="colab2D.html">mola.colab2D</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.colab3D" href="colab3D.html">mola.colab3D</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.core_box" href="core_box.html">mola.core_box</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.core_edge" href="core_edge.html">mola.core_edge</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.core_face" href="core_face.html">mola.core_face</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.core_grid" href="core_grid.html">mola.core_grid</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.core_mesh" href="core_mesh.html">mola.core_mesh</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.core_vertex" href="core_vertex.html">mola.core_vertex</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.graph" href="graph.html">mola.graph</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.grid_factory" href="grid_factory.html">mola.grid_factory</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.io" href="io.html">mola.io</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.mesh_factory" href="mesh_factory.html">mola.mesh_factory</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.mesh_marching_cubes" href="mesh_marching_cubes.html">mola.mesh_marching_cubes</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.mesh_subdivision" href="mesh_subdivision.html">mola.mesh_subdivision</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.module_blender" href="module_blender.html">mola.module_blender</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.module_compas" href="module_compas.html">mola.module_compas</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.module_processing" href="module_processing.html">mola.module_processing</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.module_rhino" href="module_rhino.html">mola.module_rhino</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.slicer" href="slicer.html">mola.slicer</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.utils_color" href="utils_color.html">mola.utils_color</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.utils_face" href="utils_face.html">mola.utils_face</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.utils_math" href="utils_math.html">mola.utils_math</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.utils_mesh" href="utils_mesh.html">mola.utils_mesh</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.utils_poly" href="utils_poly.html">mola.utils_poly</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="mola.utils_vertex" href="utils_vertex.html">mola.utils_vertex</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mola.color_faces_by_area"><code class="name flex">
<span>def <span class="ident">color_faces_by_area</span></span>(<span>faces)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigns a color to all the faces by area,
from smallest (red) to biggest (purple).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_faces_by_area(faces):
    &#34;&#34;&#34;
    Assigns a color to all the faces by area,
    from smallest (red) to biggest (purple).
    &#34;&#34;&#34;
    color_faces_by_function(faces, utils_face.face_area)</code></pre>
</details>
</dd>
<dt id="mola.color_faces_by_compactness"><code class="name flex">
<span>def <span class="ident">color_faces_by_compactness</span></span>(<span>faces)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigns a color to all the faces by compactness (area/perimeter),
from smallest (red) to biggest (purple).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_faces_by_compactness(faces):
    &#34;&#34;&#34;
    Assigns a color to all the faces by compactness (area/perimeter),
    from smallest (red) to biggest (purple).
    &#34;&#34;&#34;
    color_faces_by_function(faces, utils_face.face_compactness)</code></pre>
</details>
</dd>
<dt id="mola.color_faces_by_curvature"><code class="name flex">
<span>def <span class="ident">color_faces_by_curvature</span></span>(<span>faces)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigns a color to all the faces by curvature (require topological meshinformation),
from smallest (red) to biggest (purple).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_faces_by_curvature(faces):
    &#34;&#34;&#34;
    Assigns a color to all the faces by curvature (require topological meshinformation),
    from smallest (red) to biggest (purple).
    &#34;&#34;&#34;
    color_faces_by_function(faces, utils_face.face_curvature)</code></pre>
</details>
</dd>
<dt id="mola.color_faces_by_function"><code class="name flex">
<span>def <span class="ident">color_faces_by_function</span></span>(<span>faces, faceFunction, do_grayscale=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigns a color to all the faces by face-function which has to return a float value for a face as argument,
from smallest (red) to biggest (purple).</p>
<h2 id="arguments">Arguments:</h2>
<p>faces: list of faces to color
faceFunction : one of the functions <code>ByCurvature</code>, <code>ByArea</code>, etc.</p>
<hr>
<h2 id="optional-arguments">Optional Arguments:</h2>
<p>do_grayscale: Boolean</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_faces_by_function(faces, faceFunction, do_grayscale=False):
    &#34;&#34;&#34;
    Assigns a color to all the faces by face-function which has to return a float value for a face as argument,
    from smallest (red) to biggest (purple).

    Arguments:
    ----------
    faces: list of faces to color
    faceFunction : one of the functions `ByCurvature`, `ByArea`, etc.
    ----------
    Optional Arguments:
    ----------
    do_grayscale: Boolean
    &#34;&#34;&#34;
    values = []
    for face in faces:
        values.append(faceFunction(face))
    valueMin = min(values)
    valueMax = max(values)
    for i, face in enumerate(faces):
        h = utils_math.math_map(values[i],valueMin, valueMax, 0.0, 1.0)
        face.color = color_hue_to_rgb(h, do_grayscale)</code></pre>
</details>
</dd>
<dt id="mola.color_faces_by_horizontal_angle"><code class="name flex">
<span>def <span class="ident">color_faces_by_horizontal_angle</span></span>(<span>faces)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_faces_by_horizontal_angle(faces):
    color_faces_by_function(faces, utils_face.face_angle_horizontal)</code></pre>
</details>
</dd>
<dt id="mola.color_faces_by_map"><code class="name flex">
<span>def <span class="ident">color_faces_by_map</span></span>(<span>faces, colors)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_faces_by_map(faces, colors):
    if len(faces) &gt; len(colors):
        print(&#39;not enough colors for all the faces&#39;)
        return
    for f,c in zip(faces, colors):
        f.color = c</code></pre>
</details>
</dd>
<dt id="mola.color_faces_by_perimeter"><code class="name flex">
<span>def <span class="ident">color_faces_by_perimeter</span></span>(<span>faces)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigns a color to all the faces by perimeter,
from smallest (red) to biggest (purple).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_faces_by_perimeter(faces):
    &#34;&#34;&#34;
    Assigns a color to all the faces by perimeter,
    from smallest (red) to biggest (purple).
    &#34;&#34;&#34;
    color_faces_by_function(faces, utils_face.face_perimeter)</code></pre>
</details>
</dd>
<dt id="mola.color_faces_by_vertical_angle"><code class="name flex">
<span>def <span class="ident">color_faces_by_vertical_angle</span></span>(<span>faces)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigns a color to all the faces by verticality,
from smallest (red) to biggest (purple).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_faces_by_vertical_angle(faces):
    &#34;&#34;&#34;
    Assigns a color to all the faces by verticality,
    from smallest (red) to biggest (purple).
    &#34;&#34;&#34;
    color_faces_by_function(faces, utils_face.face_angle_vertical)</code></pre>
</details>
</dd>
<dt id="mola.color_hue_to_rgb"><code class="name flex">
<span>def <span class="ident">color_hue_to_rgb</span></span>(<span>hue, do_grayscale)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts a color defined as Hue (HSV, saturation and value assumed to be 100%) into red, green and blue
and returns (r,g,b,1)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_hue_to_rgb(hue, do_grayscale):
    &#34;&#34;&#34;
    Converts a color defined as Hue (HSV, saturation and value assumed to be 100%) into red, green and blue
    and returns (r,g,b,1)
    &#34;&#34;&#34;
    if do_grayscale:
        return (hue, hue, hue, 1)
    else:
        hue = utils_math.math_map(hue, 0.0, 1.0, 0.0, 0.8) #limit hue red-red to red-magenta
        col = colorsys.hsv_to_rgb(hue, 1, 1)
        return (col[0], col[1], col[2], 1) # alpha = 100 %</code></pre>
</details>
</dd>
<dt id="mola.color_map"><code class="name flex">
<span>def <span class="ident">color_map</span></span>(<span>values=[], colors=[(1, 0, 0.5), (0, 0.5, 1)])</span>
</code></dt>
<dd>
<section class="desc"><p>Maps a value to a color on a custom spectrum.
The values will be remapped from 0 to 1, the first color will be at 0, the
last at 1 and all other colors evenly spread between.</p>
<h2 id="arguments">Arguments:</h2>
<p>values : list of floats
the list of values to be mapped
colors : list of (r,g,b) tuples
the colors along the spectrum</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_map(values=[], colors=[(1,0,0.5),(0,0.5,1)]):
    &#34;&#34;&#34;
    Maps a value to a color on a custom spectrum.
    The values will be remapped from 0 to 1, the first color will be at 0, the
    last at 1 and all other colors evenly spread between.

    Arguments:
    ----------
    values : list of floats
        the list of values to be mapped
    colors : list of (r,g,b) tuples
        the colors along the spectrum
    &#34;&#34;&#34;
    value_min = min(values)
    value_max = max(values)
    values_mapped = [utils_math.math_map(v, value_min, value_max, 0.0, 0.999) for v in values]
    interval = 1.0 / (len(colors) - 1)
    output_colors = []
    for v in values_mapped:
        lower_ix = int(floor(v * (len(colors)-1)))
        upper_ix = lower_ix + 1
        rv = (v - (lower_ix * interval)) / interval
        r = (1 - rv) * colors[lower_ix][0] + rv * colors[upper_ix][0]
        g = (1 - rv) * colors[lower_ix][1] + rv * colors[upper_ix][1]
        b = (1 - rv) * colors[lower_ix][2] + rv * colors[upper_ix][2]
        output_colors.append((r,g,b,1))
    return output_colors</code></pre>
</details>
</dd>
<dt id="mola.construct_box"><code class="name flex">
<span>def <span class="ident">construct_box</span></span>(<span>x1, y1, z1, x2, y2, z2)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and returns a mesh box with six quad faces.</p>
<h2 id="arguments">Arguments:</h2>
<p>x1,y1,z1 : float<br>
The coordinates of the bottom left front corner<br>
x2,y2,z2 : float<br>
The coordinates of the top right back corner<br></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_box(x1,y1,z1,x2,y2,z2):
    &#34;&#34;&#34;
    Creates and returns a mesh box with six quad faces.

    Arguments:
    ----------
    x1,y1,z1 : float&lt;br&gt;
        The coordinates of the bottom left front corner&lt;br&gt;
    x2,y2,z2 : float&lt;br&gt;
        The coordinates of the top right back corner&lt;br&gt;
    &#34;&#34;&#34;
    mesh = Mesh()
    v1 = Vertex(x1, y1, z1)
    v2 = Vertex(x1, y2, z1)
    v3 = Vertex(x2, y2, z1)
    v4 = Vertex(x2, y1, z1)
    v5 = Vertex(x1, y1, z2)
    v6 = Vertex(x1, y2, z2)
    v7 = Vertex(x2, y2, z2)
    v8 = Vertex(x2, y1, z2)
    mesh.vertices = [v1, v2, v3, v4, v5, v6, v7, v8]
    f1 = Face([v1, v2, v3, v4])
    f2 = Face([v8, v7, v6, v5])
    f3 = Face([v4, v3, v7, v8])
    f4 = Face([v3, v2, v6, v7])
    f5 = Face([v2, v1, v5, v6])
    f6 = Face([v1, v4, v8, v5])
    mesh.faces = [f1, f2, f3, f4, f5, f6]
    mesh.update_topology()
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.construct_circle"><code class="name flex">
<span>def <span class="ident">construct_circle</span></span>(<span>radius, segments, z=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_circle(radius, segments, z=0):
    vertices = []
    deltaAngle = math.pi * 2.0 / segments
    for i in range(segments):
        cAngle = i * deltaAngle
        vertices.append(Vertex(math.cos(cAngle) * radius, math.sin(cAngle) * radius, z))
    return vertices</code></pre>
</details>
</dd>
<dt id="mola.construct_cone"><code class="name flex">
<span>def <span class="ident">construct_cone</span></span>(<span>z1, z2, radius1, radius2, nSegments, capBottom=True, capTop=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and returns a conic cylinder.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_cone(z1, z2, radius1, radius2, nSegments, capBottom=True, capTop=True):
    &#34;&#34;&#34;
    Creates and returns a conic cylinder.
    &#34;&#34;&#34;
    delaAngle = math.radians(360.0 / nSegments)
    angle = 0
    verticesBottom = []
    verticesTop = []
    for i in range(nSegments):
        x1 = radius1 * math.cos(angle)
        y1 = radius1 * math.sin(angle)
        verticesBottom.append(Vertex(x1, y1, z1))
        x2 = radius2 * math.cos(angle)
        y2 = radius2 * math.sin(angle)
        verticesTop.append(Vertex(x2, y2, z2))
        angle += delaAngle

    mesh = Mesh()
    mesh.vertices.extend(verticesBottom)
    mesh.vertices.extend(verticesTop)
    for i in range(nSegments):
        i2 = (i + 1) % nSegments
        mesh.faces.append(Face([verticesBottom[i],verticesBottom[i2],verticesTop[i2],verticesTop[i]]))
    if capBottom:
        # centerBottom = Vertex(0, 0, z1)
        # mesh.vertices.append(centerBottom)
        # for i in range(nSegments):
        #     i2=(i+1)%nSegments
        #     mesh.faces.append(Face([verticesBottom[i2],verticesBottom[i],centerBottom]))
        mesh.faces.append(Face(list(reversed(verticesBottom))))
    if capTop:
        # centerTop=Vertex(0,0,z2)
        # mesh.vertices.append(centerTop)
        # for i in range(nSegments):
        #     i2=(i+1)%nSegments
        #     mesh.faces.append(Face([verticesTop[i],verticesTop[i2],centerTop]))
        mesh.faces.append(Face(verticesTop))
    mesh.update_topology()
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.construct_dodecahedron"><code class="name flex">
<span>def <span class="ident">construct_dodecahedron</span></span>(<span>radius=1, cx=0, cy=0, cz=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs a dodecaheron mesh.</p>
<h2 id="optional-arguments">Optional Arguments:</h2>
<p>radius : float
The radius of the containing sphere
cx,cy,cz : float
The coordinates of the center point.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_dodecahedron(radius=1, cx=0,cy=0,cz=0):
    &#34;&#34;&#34;
    Constructs a dodecaheron mesh.

    Optional Arguments:
    ----------
    radius : float
        The radius of the containing sphere
    cx,cy,cz : float
        The coordinates of the center point.
    &#34;&#34;&#34;
    mesh = Mesh()
    phi = (1 + 5 ** 0.5) / 2
    mesh.vertices = [Vertex( 1, 1, 1),
                Vertex( 1, 1,-1),
                Vertex( 1,-1, 1),
                Vertex( 1,-1,-1),
                Vertex(-1, 1, 1),
                Vertex(-1, 1,-1),
                Vertex(-1,-1, 1),
                Vertex(-1,-1,-1),
                Vertex(0,-phi,-1/phi),
                Vertex(0,-phi, 1/phi),
                Vertex(0, phi,-1/phi),
                Vertex(0, phi, 1/phi),
                Vertex(-phi,-1/phi,0),
                Vertex(-phi, 1/phi,0),
                Vertex( phi,-1/phi,0),
                Vertex( phi, 1/phi,0),
                Vertex(-1/phi,0,-phi),
                Vertex( 1/phi,0,-phi),
                Vertex(-1/phi,0, phi),
                Vertex( 1/phi,0, phi)]

    for i in range(len(mesh.vertices)):
        mesh.vertices[i] = utils_vertex.vertex_scale(mesh.vertices[i], radius)
        mesh.vertices[i] = utils_vertex.vertex_add(mesh.vertices[i], Vertex(cx,cy,cz))
    indices = [2,9,6,18,19,
               4,11,0,19,18,
               18,6,12,13,4,
               19,0,15,14,2,
               4,13,5,10,11,
               14,15,1,17,3,
               1,15,0,11,10,
               3,17,16,7,8,
               2,14,3,8,9,
               6,9,8,7,12,
               1,10,5,16,17,
               12,7,16,5,13]

    for i in range(0, len(indices), 5):
        f = Face([mesh.vertices[indices[i]],
                  mesh.vertices[indices[i + 1]],
                  mesh.vertices[indices[i + 2]],
                  mesh.vertices[indices[i + 3]],
                  mesh.vertices[indices[i + 4]]])
        mesh.faces.append(f)
    mesh.update_topology()
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.construct_icosahedron"><code class="name flex">
<span>def <span class="ident">construct_icosahedron</span></span>(<span>radius=1, cx=0, cy=0, cz=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and returns a mesh in the form of an icosahedron.</p>
<h2 id="optional-arguments">Optional Arguments:</h2>
<p>radius : float
The radius of the containing sphere.
cx,cy,cz : float
The coordinates of the center point.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_icosahedron(radius=1,cx=0,cy=0,cz=0):
    &#34;&#34;&#34;
    Creates and returns a mesh in the form of an icosahedron.

    Optional Arguments:
    ----------
    radius : float
        The radius of the containing sphere.
    cx,cy,cz : float
        The coordinates of the center point.
    &#34;&#34;&#34;
    mesh = Mesh()
    phi = (1 + 5 ** 0.5) / 2
    coordA = 1 / (2 * math.sin(2 * math.pi / 5))
    coordB = phi / (2 * math.sin(2 * math.pi / 5))
    mesh.vertices = [Vertex(0, -coordA, coordB),
                Vertex(coordB, 0, coordA),
                Vertex(coordB, 0, -coordA),
                Vertex(-coordB, 0, -coordA),
                Vertex(-coordB, 0, coordA),
                Vertex(-coordA, coordB, 0),
                Vertex(coordA, coordB, 0),
                Vertex(coordA, -coordB, 0),
                Vertex(-coordA, -coordB, 0),
                Vertex(0, -coordA, -coordB),
                Vertex(0, coordA, -coordB),
                Vertex(0, coordA, coordB)]

    for i in range(len(mesh.vertices)):
        mesh.vertices[i] = utils_vertex.vertex_scale(mesh.vertices[i], radius)
        mesh.vertices[i] = utils_vertex.vertex_add(mesh.vertices[i], Vertex(cx,cy,cz))

    indices = [1, 2, 6, 1, 7, 2, 3, 4, 5, 4, 3, 8, 6, 5, 11, 5, 6, 10, 9, 10, 2, 10, 9, 3, 7, 8, 9, 8, 7, 0, 11, 0, 1, 0, 11, 4, 6, 2, 10, 1, 6, 11, 3, 5, 10, 5, 4, 11, 2, 7, 9, 7, 1, 0, 3, 9, 8, 4, 8, 0]
    faces = []

    for i in range(0,len(indices),3):
        f = Face([mesh.vertices[indices[i]], mesh.vertices[indices[i + 1]], mesh.vertices[indices[i + 2]]])
        faces.append(f)
    mesh.faces = faces
    mesh.update_topology()
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.construct_octahedron"><code class="name flex">
<span>def <span class="ident">construct_octahedron</span></span>(<span>edgeLen=1, cx=0, cy=0, cz=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_octahedron(edgeLen=1, cx=0, cy=0, cz=0):
    mesh = Mesh()
    #make vertices
    mesh.vertices = [Vertex(0, 0, edgeLen/2),
                     Vertex(-edgeLen/2, 0, 0),
                     Vertex(0, -edgeLen/2, 0),
                     Vertex(edgeLen/2, 0, 0),
                     Vertex(0, edgeLen/2, 0),
                     Vertex(0, 0, -edgeLen/2)]

    #move center to desired coordinates
    center = Vertex(cx, cy, cz)
    for v in mesh.vertices:
        v.add(center)

    #construct triangular faces
    f1 = Face([mesh.vertices[0], mesh.vertices[1], mesh.vertices[2]])
    f2 = Face([mesh.vertices[0], mesh.vertices[2], mesh.vertices[3]])
    f3 = Face([mesh.vertices[0], mesh.vertices[3], mesh.vertices[4]])
    f4 = Face([mesh.vertices[0], mesh.vertices[4], mesh.vertices[1]])
    f5 = Face([mesh.vertices[5], mesh.vertices[2], mesh.vertices[1]])
    f6 = Face([mesh.vertices[5], mesh.vertices[3], mesh.vertices[2]])
    f7 = Face([mesh.vertices[5], mesh.vertices[4], mesh.vertices[3]])
    f8 = Face([mesh.vertices[5], mesh.vertices[1], mesh.vertices[4]])

    mesh.faces = [f1,f2,f3,f4,f5,f6,f7,f8]
    mesh.update_topology()
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.construct_rhombic_dodecahedron"><code class="name flex">
<span>def <span class="ident">construct_rhombic_dodecahedron</span></span>(<span>edge_length=1, cx=0, cy=0, cz=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_rhombic_dodecahedron(edge_length=1, cx=0, cy=0, cz=0):
    mesh = Mesh()
    #make vertices
    mesh.vertices = [Vertex(0,  0, 2 * edge_length),
                     Vertex(-edge_length, edge_length, edge_length),
                     Vertex(-edge_length, -edge_length, edge_length),
                     Vertex(edge_length, -edge_length, edge_length),
                     Vertex(edge_length, edge_length, edge_length),
                     Vertex(-2 * edge_length, 0, 0),
                     Vertex(0, -2*edge_length, 0),
                     Vertex(2 * edge_length, 0, 0),
                     Vertex(0, 2 * edge_length, 0),
                     Vertex(-edge_length, edge_length, -edge_length),
                     Vertex(-edge_length, -edge_length, -edge_length),
                     Vertex(edge_length, -edge_length, -edge_length),
                     Vertex(edge_length, edge_length, -edge_length),
                     Vertex(0, 0, -2 * edge_length)]

    #move center to desired coordinates
    center = Vertex(cx, cy, cz)
    for v in mesh.vertices:
        v.add(center)

    #construct quad faces
    f1 = Face([mesh.vertices[0],mesh.vertices[2],mesh.vertices[5],mesh.vertices[1]])
    f2 = Face([mesh.vertices[0],mesh.vertices[3],mesh.vertices[6],mesh.vertices[2]])
    f3 = Face([mesh.vertices[0],mesh.vertices[4],mesh.vertices[7],mesh.vertices[3]])
    f4 = Face([mesh.vertices[0],mesh.vertices[1],mesh.vertices[8],mesh.vertices[4]])
    f5 = Face([mesh.vertices[2],mesh.vertices[6],mesh.vertices[10],mesh.vertices[5]])
    f6 = Face([mesh.vertices[3],mesh.vertices[7],mesh.vertices[11],mesh.vertices[6]])
    f7 = Face([mesh.vertices[4],mesh.vertices[8],mesh.vertices[12],mesh.vertices[7]])
    f8 = Face([mesh.vertices[1],mesh.vertices[5],mesh.vertices[9],mesh.vertices[8]])
    f9 = Face([mesh.vertices[10],mesh.vertices[13],mesh.vertices[9],mesh.vertices[5]])
    f10 = Face([mesh.vertices[11],mesh.vertices[13],mesh.vertices[10],mesh.vertices[6]])
    f11 = Face([mesh.vertices[12],mesh.vertices[13],mesh.vertices[11],mesh.vertices[7]])
    f12 = Face([mesh.vertices[9],mesh.vertices[13],mesh.vertices[12],mesh.vertices[8]])

    mesh.faces = [f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12]
    mesh.update_topology()
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.construct_single_face"><code class="name flex">
<span>def <span class="ident">construct_single_face</span></span>(<span>vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and returns a single face mesh from the vertices.</p>
<h2 id="arguments">Arguments:</h2>
<p>vertices : list of mola.core.Vertex
The vertices describing the face</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_single_face(vertices):
    &#34;&#34;&#34;
    Creates and returns a single face mesh from the vertices.

    Arguments:
    ----------
    vertices : list of mola.core.Vertex
        The vertices describing the face
    &#34;&#34;&#34;
    mesh = Mesh()
    mesh.vertices = vertices
    mesh.faces = [Face(vertices)]
    mesh.update_topology()
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.construct_tetrahedron"><code class="name flex">
<span>def <span class="ident">construct_tetrahedron</span></span>(<span>size=1, cx=0, cy=0, cz=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs a tetrahedron mesh.</p>
<h2 id="optional-arguments">Optional Arguments:</h2>
<p>side : float
The edge length of the tetrahedron
cx,cy,cz : float
The coordinates of the center point.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_tetrahedron(size=1,cx=0,cy=0,cz=0):
    &#34;&#34;&#34;
    Constructs a tetrahedron mesh.

    Optional Arguments:
    ----------
    side : float
        The edge length of the tetrahedron
    cx,cy,cz : float
        The coordinates of the center point.
    &#34;&#34;&#34;

    mesh = Mesh()
    coord = 1 / math.sqrt(2)
    mesh.vertices = [Vertex(+1, 0, -coord),
                     Vertex(-1, 0, -coord),
                     Vertex(0, +1, +coord),
                     Vertex(0, -1, +coord)]

    for i in range(len(mesh.vertices)):
        mesh.vertices[i] = utils_vertex.vertex_scale(mesh.vertices[i], size / 2)
        mesh.vertices[i] = utils_vertex.vertex_add(mesh.vertices[i], Vertex(cx, cy, cz))

    f1 = Face([mesh.vertices[0], mesh.vertices[1], mesh.vertices[2]])
    f2 = Face([mesh.vertices[1], mesh.vertices[0], mesh.vertices[3]])
    f3 = Face([mesh.vertices[2], mesh.vertices[3], mesh.vertices[0]])
    f4 = Face([mesh.vertices[3], mesh.vertices[2], mesh.vertices[1]])

    mesh.faces = [f1, f2, f3, f4]
    mesh.update_topology()
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.construct_torus"><code class="name flex">
<span>def <span class="ident">construct_torus</span></span>(<span>ringRadius, tubeRadius, ringN=16, tubeN=16)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs a torus mesh.</p>
<h2 id="arguments">Arguments:</h2>
<p>ringRadius : float
the big radius of the axis
tubeRadius : float
radius of the the tube along the axis</p>
<h2 id="optional-arguments">Optional Arguments:</h2>
<p>ringN : int
resolution along the ring
tubeN : int
resolution along the tube</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_torus(ringRadius, tubeRadius, ringN = 16, tubeN = 16):
    &#34;&#34;&#34;
    Constructs a torus mesh.

    Arguments:
    ----------
    ringRadius : float
        the big radius of the axis
    tubeRadius : float
        radius of the the tube along the axis

    Optional Arguments:
    ----------
    ringN : int
        resolution along the ring
    tubeN : int
        resolution along the tube
    &#34;&#34;&#34;
    mesh = Mesh()
    theta = 2 * math.pi / ringN
    phi = 2 * math.pi / tubeN

    for i in range (ringN):
        for j in range (tubeN):
            mesh.vertices.append(_torus_vertex(ringRadius, tubeRadius, phi * j, theta * i))

    for i in range(ringN):
        ii = (i + 1) % ringN
        for j in range(tubeN):
            jj = (j + 1) % tubeN
            a = i  * tubeN + j
            b = ii * tubeN + j
            c = ii * tubeN + jj
            d = i  * tubeN + jj
            f = Face([mesh.vertices[k] for k in [a, b, c, d]])
            mesh.faces.append(f)
    mesh.update_topology()
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.export_obj"><code class="name flex">
<span>def <span class="ident">export_obj</span></span>(<span>mesh, fileNameOBJ, exportColors=True, exportGroups=True, weldVertices=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_obj(mesh,fileNameOBJ,exportColors=True,exportGroups=True,weldVertices=True):
    export_obj_faces(mesh.faces,fileNameOBJ,exportColors,exportGroups,weldVertices)</code></pre>
</details>
</dd>
<dt id="mola.export_obj_faces"><code class="name flex">
<span>def <span class="ident">export_obj_faces</span></span>(<span>faces, fileNameOBJ, exportColors=True, exportGroups=True, weldVertices=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Exports the faces as an Alias wavefront obj file.</p>
<h2 id="arguments">Arguments:</h2>
<p>faces : list of mola.core.Face
The face to be measured
fileNameOBJ : String
The path and filename for the *.obj mesh file</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_obj_faces(faces,fileNameOBJ,exportColors=True,exportGroups=True,weldVertices=True):
    &#34;&#34;&#34;
    Exports the faces as an Alias wavefront obj file.

    Arguments:
    ----------
    faces : list of mola.core.Face
        The face to be measured
    fileNameOBJ : String
        The path and filename for the *.obj mesh file
    &#34;&#34;&#34;
    file = open(fileNameOBJ, &#34;w&#34;)
    if exportColors:
        fileNameMTL = ntpath.basename(fileNameOBJ) + &#34;.mtl&#34;
        file.write(&#34;mtllib ./&#34; + fileNameMTL + &#34;\n&#34;)
        fileMTL = open(fileNameOBJ + &#34;.mtl&#34;, &#34;w&#34;)
        materials = {}

    if exportGroups:
        faces.sort(key = lambda x: x.group)

    vertexCount = 0
    vertices = {}
    currentGroup = None

    for face in faces:
        if exportGroups and face.group != currentGroup:
            file.write(&#34;g &#34; + str(face.group) + &#34;\n&#34;)
            currentGroup = face.group
        if exportColors:
            materials[__strColor(face.color)] = face.color
            file.write(&#34;usemtl material&#34; + __strColor(face.color) + &#34;\n&#34;)
        faceString = &#34;f&#34;

        if weldVertices:
            for p in face.vertices:
                ptuple = (p.x,p.y,p.z)
                if ptuple in vertices:
                    faceString += &#34; &#34; + str(vertices[ptuple])
                else:
                    vertexCount += 1
                    faceString += &#34; &#34;+str(vertexCount)
                    vertices[ptuple] = vertexCount
                    file.write(&#34;v &#34; + str(p.x) + &#34; &#34; + str(p.y) + &#34; &#34; + str(p.z) + &#34;\n&#34;)
        else:
            for p in face.vertices:
                vertexCount += 1
                faceString += &#34; &#34; + str(vertexCount)
                file.write(&#34;v &#34; + str(p.x) + &#34; &#34; + str(p.y) + &#34; &#34; + str(p.z) + &#34;\n&#34;)

        faceString += &#34;\n&#34;
        file.write(faceString)
    file.close()

    if exportColors:
        for mat in materials.values():
            fileMTL.write(&#34;newmtl material&#34; + __strColor(mat) + &#34;\n&#34;)
            fileMTL.write(&#34;Kd &#34; + str(mat[0]) + &#34; &#34; + str(mat[1]) + &#34; &#34; + str(mat[2]) + &#34;\n&#34;)
        fileMTL.close()</code></pre>
</details>
</dd>
<dt id="mola.face_angle_horizontal"><code class="name flex">
<span>def <span class="ident">face_angle_horizontal</span></span>(<span>face)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the azimuth, the orientation of the face around the z-axis in the XY-plane</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.Face
The face to be measured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_angle_horizontal(face):
    &#34;&#34;&#34;
    Returns the azimuth, the orientation of the face around the z-axis in the XY-plane

    Arguments:
    ----------
    face : mola.Face
            The face to be measured
    &#34;&#34;&#34;
    n = face_normal(face)
    return math.atan2(n.y, n.x)</code></pre>
</details>
</dd>
<dt id="mola.face_angle_vertical"><code class="name flex">
<span>def <span class="ident">face_angle_vertical</span></span>(<span>f)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the altitude, 0 if the face is vertical, -Pi/2 if it faces downwards, +Pi/2 if it faces upwards.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.Face
The face to be measured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_angle_vertical(f):
    &#34;&#34;&#34;
    Returns the altitude, 0 if the face is vertical, -Pi/2 if it faces downwards, +Pi/2 if it faces upwards.

    Arguments:
    ----------
    face : mola.Face
            The face to be measured
    &#34;&#34;&#34;
    n = face_normal(f)
    #nXY = Vertex(n.x, n.y, 0.0)
    #return vecUtils.angle(n, nXY)
    # alternative, probably less computationally intense:
    return math.asin(n.z)</code></pre>
</details>
</dd>
<dt id="mola.face_area"><code class="name flex">
<span>def <span class="ident">face_area</span></span>(<span>face)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the area of a face, for quads that of two triangles.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.Face
The face to be measured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_area(face):
    &#34;&#34;&#34;
    Returns the area of a face, for quads that of two triangles.

    Arguments:
    ----------
    face : mola.Face
            The face to be measured
    &#34;&#34;&#34;
    if(len(face.vertices) == 3):
        return utils_vertex.triangle_area(face.vertices[0], face.vertices[1], face.vertices[2])
    else:
        return utils_vertex.triangle_area(face.vertices[0], face.vertices[1], face.vertices[2]) + utils_vertex.triangle_area(face.vertices[2], face.vertices[3], face.vertices[0])</code></pre>
</details>
</dd>
<dt id="mola.face_center"><code class="name flex">
<span>def <span class="ident">face_center</span></span>(<span>face)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the center point (type Vertex) of a face.
Note: not the center of gravity, just the average of its vertices.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.Face
The face to be measured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_center(face):
    &#34;&#34;&#34;
    Returns the center point (type Vertex) of a face.
    Note: not the center of gravity, just the average of its vertices.

    Arguments:
    ----------
    face : mola.Face
            The face to be measured
    &#34;&#34;&#34;
    return utils_vertex.vertices_list_center(face.vertices)</code></pre>
</details>
</dd>
<dt id="mola.face_compactness"><code class="name flex">
<span>def <span class="ident">face_compactness</span></span>(<span>face)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the compactness of a face as the ratio between area and perimeter.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.Face
The face to be measured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_compactness(face):
    &#34;&#34;&#34;
    Returns the compactness of a face as the ratio between area and perimeter.

    Arguments:
    ----------
    face : mola.Face
            The face to be measured
    &#34;&#34;&#34;
    return face_area(face) / face_perimeter(face)</code></pre>
</details>
</dd>
<dt id="mola.face_copy_properties"><code class="name flex">
<span>def <span class="ident">face_copy_properties</span></span>(<span>faceParent, faceChild)</span>
</code></dt>
<dd>
<section class="desc"><p>Copies the properties (color,group,&hellip;) of faceParent to faceChild.</p>
<h2 id="arguments">Arguments:</h2>
<p>faceParent : mola.Face
The face to copy the properties From.
faceChild : mola.Face
The face to copy the properties To.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_copy_properties(faceParent,faceChild):
    &#34;&#34;&#34;
    Copies the properties (color,group,...) of faceParent to faceChild.

    Arguments:
    ----------
    faceParent : mola.Face
                 The face to copy the properties From.
    faceChild : mola.Face
                 The face to copy the properties To.
    &#34;&#34;&#34;
    faceChild.group = faceParent.group
    faceChild.color = faceParent.color</code></pre>
</details>
</dd>
<dt id="mola.face_curvature"><code class="name flex">
<span>def <span class="ident">face_curvature</span></span>(<span>face)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the local curvature of a mesh face, by measuring the angle to the neighbour faces.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.Face
The face to be measured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_curvature(face):
    &#34;&#34;&#34;
    Returns the local curvature of a mesh face, by measuring the angle to the neighbour faces.

    Arguments:
    ----------
    face : mola.Face
        The face to be measured
    &#34;&#34;&#34;
    facenormal = face_normal(face)
    sumD = 0
    vPrev = face.vertices[-1]
    num_faces = 1
    for v in face.vertices:
        edge = v.edge_adjacent_to_vertex(vPrev)
        if edge != None:
            nbFace = edge.face1
            if edge.face1 == face:
                nbFace = edge.face2
            if nbFace != None:
                num_faces += 1
                nbNormal = face_normal(nbFace)
                sumD += utils_vertex.vertex_distance(nbNormal,facenormal)
        vPrev = v
    return sumD / num_faces</code></pre>
</details>
</dd>
<dt id="mola.face_normal"><code class="name flex">
<span>def <span class="ident">face_normal</span></span>(<span>face)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the normal of a face, a vector of length 1 perpendicular to the plane of the triangle.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.Face
the face to get the normal from</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_normal(face):
    &#34;&#34;&#34;
    Returns the normal of a face, a vector of length 1 perpendicular to the plane of the triangle.

    Arguments:
    ----------
    face : mola.Face
        the face to get the normal from
    &#34;&#34;&#34;
    return utils_vertex.triangle_normal(face.vertices[0], face.vertices[1], face.vertices[2])</code></pre>
</details>
</dd>
<dt id="mola.face_perimeter"><code class="name flex">
<span>def <span class="ident">face_perimeter</span></span>(<span>face)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the perimeter of a face as the sum of all the edges' lengths.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.Face
The face to be measured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_perimeter(face):
    &#34;&#34;&#34;
    Returns the perimeter of a face as the sum of all the edges&#39; lengths.

    Arguments:
    ----------
    face : mola.Face
            The face to be measured
    &#34;&#34;&#34;
    sum = 0
    for i in range(len(face.vertices)):
        v1 = face.vertices[i]
        v2 = face.vertices[(i + 1) % len(face.vertices)]
        sum += utils_vertex.vertex_distance(v1,v2)
    return sum</code></pre>
</details>
</dd>
<dt id="mola.face_scale"><code class="name flex">
<span>def <span class="ident">face_scale</span></span>(<span>face, factor=1.0, origin=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_scale(face, factor=1.0, origin=None):
    if origin is None:
        for v in face.vertices:
            v.scale(factor)
    else:
        for v in face.vertices:
            delta = v - origin
            delta.scale(factor)
            v.x = origin.x + delta.x
            v.y = origin.y + delta.y
            v.z = origin.z + delta.z
    return face</code></pre>
</details>
</dd>
<dt id="mola.floor"><code class="name flex">
<span>def <span class="ident">floor</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>floor(x)</p>
<p>Return the floor of x as an Integral.
This is the largest integer &lt;= x.</p></section>
</dd>
<dt id="mola.grid_set_values_at_borders"><code class="name flex">
<span>def <span class="ident">grid_set_values_at_borders</span></span>(<span>grid, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid_set_values_at_borders(grid, value):
    for i in range(grid.nx):
        for j in range(grid.ny):
            for k in range(grid.nz):
                if (i==0 or i==grid.nx-1):
                    grid.set_value_at_xyz(value,i,j,k)
                elif (j==0 or j==grid.ny-1):
                    grid.set_value_at_xyz(value,i,j,k)
                elif (k==0 or k==grid.nz-1):
                    grid.set_value_at_xyz(value,i,j,k)</code></pre>
</details>
</dd>
<dt id="mola.grid_set_values_sinusoids"><code class="name flex">
<span>def <span class="ident">grid_set_values_sinusoids</span></span>(<span>grid, freq_x=18.84955592153876, freq_y=18.84955592153876, freq_z=18.84955592153876)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid_set_values_sinusoids(grid, freq_x=6*math.pi, freq_y=6*math.pi, freq_z=6*math.pi):
    for i in range(grid.nx):
        for j in range(grid.ny):
            for k in range(grid.nz):
                vx = math.sin(i/grid.nx * freq_x)
                vy = math.sin(j/grid.ny * freq_y)
                vz = math.sin(k/grid.nz * freq_z)
                v = utils_math.math_map((vx+vy+vz),-3.0,3.0,-1.0,1.0)
                grid.set_value_at_xyz(v,i,j,k)</code></pre>
</details>
</dd>
<dt id="mola.import_obj"><code class="name flex">
<span>def <span class="ident">import_obj</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads a Wavefront OBJ file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_obj(filename):
    &#34;&#34;&#34;Loads a Wavefront OBJ file. &#34;&#34;&#34;
    mesh = Mesh()
    group = &#34;&#34;
    for line in open(filename, &#34;r&#34;):
        if line.startswith(&#39;#&#39;): continue
        values = line.split()
        if not values: continue
        if values[0] == &#39;g&#39;:
            group=values[1]
        elif values[0] == &#39;v&#39;:
            v = [float(c) for c in values[1 : 4]]
            #v = map(float, values[1:4])
            mesh.vertices.append(Vertex(v[0],v[1],v[2]))
        elif values[0] == &#39;f&#39;:
            face = Face([])
            face.group = group
            for v in values[1:]:
                w = v.split(&#39;/&#39;)
                vertex = mesh.vertices[int(w[0]) - 1]
                face.vertices.append(vertex)
            mesh.faces.append(face)
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.import_obj_faces"><code class="name flex">
<span>def <span class="ident">import_obj_faces</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads a Wavefront OBJ file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_obj_faces(filename):
    &#34;&#34;&#34;Loads a Wavefront OBJ file. &#34;&#34;&#34;
    return import_obj(filename).faces</code></pre>
</details>
</dd>
<dt id="mola.marching_cubes"><code class="name flex">
<span>def <span class="ident">marching_cubes</span></span>(<span>nX, nY, nZ, values, iso, scale_to_canvas=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def marching_cubes(nX,nY,nZ,values,iso, scale_to_canvas=False):
    mesh =  Mesh()
    nYZ = nY * nZ
    index = 0
    n =[0]*8
    switcher = {
        0:lambda: Vertex(x + _v(n[0], n[1], iso), y + 1, z),
        1:lambda: Vertex(x + 1, y + _v(n[2], n[1], iso), z),
        2:lambda: Vertex(x + _v(n[3], n[2], iso), y, z),
        3:lambda: Vertex(x, y + _v(n[3], n[0], iso), z),
        4:lambda: Vertex(x + _v(n[4], n[5], iso), y + 1, z + 1),
        5:lambda: Vertex(x + 1, y + _v(n[6], n[5], iso), z + 1),
        6:lambda: Vertex(x + _v(n[7], n[6], iso), y, z + 1),
        7:lambda: Vertex(x, y + _v(n[7], n[4], iso), z + 1),
        8:lambda: Vertex(x, y + 1, z + _v(n[0], n[4], iso)),
        9:lambda: Vertex(x + 1, y + 1, z + _v(n[1], n[5], iso)),
        10:lambda: Vertex(x, y, z + _v(n[3], n[7], iso)),
        11:lambda: Vertex(x + 1, y, z + _v(n[2], n[6], iso))
    }
    for x in range(nX - 1):
        for y in range(nY - 1):
            for z in range(nZ - 1):
                caseNumber = 0
                index = z + y * nZ + x * nYZ
                # collecting the values
                n[0] = values[index + nZ]# 0,1,0
                n[1] = values[index + nYZ + nZ]#1,1,0
                n[2] = values[index + nYZ]# 1,0,0
                n[3] = values[index]# 0,0,0
                n[4] = values[index + nZ + 1]# 0,1,1
                n[5] = values[index + nYZ + nZ + 1]# 1,1,1
                n[6] = values[index + nYZ + 1]# 1,0,1
                n[7] = values[index + 1]# 0,0,1
                for i in range(7,-1,-1):
                    if n[i] &gt; iso:
                        caseNumber+=1
                    if i &gt; 0:
                        caseNumber = caseNumber &lt;&lt; 1
                # collecting the faces
                offset = caseNumber * 15
                for i in range(offset,offset + 15,3):
                    if _faces[i] &gt; -1:
                        vs=[]
                        for j in range(i,i+3):
                            v = switcher[_faces[j]]()
                            mesh.vertices.append(v)
                            vs.append(v)
                            if len(vs) == 3:
                                mesh.faces.append(Face(vs))

    mesh.update_topology()
    if(scale_to_canvas):
        mesh.translate(-nX/2.0,-nY/2.0,-nZ/2.0)
        sc = 20.0/max(nX,nY)
        mesh.scale(sc,sc,sc)

    return mesh</code></pre>
</details>
</dd>
<dt id="mola.marching_cubes_from_grid"><code class="name flex">
<span>def <span class="ident">marching_cubes_from_grid</span></span>(<span>grid, iso)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def marching_cubes_from_grid(grid,iso):
    return marching_cubes(grid.nx,grid.ny,grid.nz,grid.values,iso,grid.scale_to_canvas)</code></pre>
</details>
</dd>
<dt id="mola.math_determinant"><code class="name flex">
<span>def <span class="ident">math_determinant</span></span>(<span>a, b, c, d, e, f, g, h, i)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the determinant of the 9 values of a 3 x 3 matrix</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def math_determinant(a, b, c, d, e, f, g, h, i):
    &#34;&#34;&#34;
    returns the determinant of the 9 values of a 3 x 3 matrix
    &#34;&#34;&#34;
    return (a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g)</code></pre>
</details>
</dd>
<dt id="mola.math_map"><code class="name flex">
<span>def <span class="ident">math_map</span></span>(<span>value, fromMin, fromMax, toMin, toMax)</span>
</code></dt>
<dd>
<section class="desc"><p>Maps a value from one range to another.
Arguments:</p>
<hr>
<p>value : value to be mapped
fromMin : lower bound of the value's current range
fromMax : upper bound of the value's current range
toMin : lower bound of the value's target range
toMax : upper bound of the value's target range</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def math_map(value, fromMin, fromMax, toMin, toMax):
    &#34;&#34;&#34;
    Maps a value from one range to another.
    Arguments:
    ----------
    value : value to be mapped
    fromMin : lower bound of the value&#39;s current range
    fromMax : upper bound of the value&#39;s current range
    toMin : lower bound of the value&#39;s target range
    toMax : upper bound of the value&#39;s target range
    &#34;&#34;&#34;
    delta = fromMax - fromMin
    if delta == 0 : return 0
    return toMin + ((toMax - toMin) / delta) * (value - fromMin)</code></pre>
</details>
</dd>
<dt id="mola.math_map_list"><code class="name flex">
<span>def <span class="ident">math_map_list</span></span>(<span>values, toMin=0, toMax=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Maps the values of a list from a minimum value to a maximum value.
Arguments:</p>
<hr>
<p>values : list to be mapped</p>
<h2 id="optional-arguments">Optional Arguments:</h2>
<p>toMin : minimum value of the list's target range (default = 0)
toMax : maximum value of the list's target range (default = 1)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def math_map_list(values,toMin=0,toMax=1):
    &#34;&#34;&#34;
    Maps the values of a list from a minimum value to a maximum value.
    Arguments:
    ----------
    values : list to be mapped

    Optional Arguments:
    ----------
    toMin : minimum value of the list&#39;s target range (default = 0)
    toMax : maximum value of the list&#39;s target range (default = 1)
    &#34;&#34;&#34;
    minValue=min(values)
    maxValue=max(values)
    delta=maxValue-minValue
    deltaTarget=toMax-toMin
    return list(map(lambda x: toMin+deltaTarget*(x-minValue)/delta, values))</code></pre>
</details>
</dd>
<dt id="mola.mesh_smooth_laplacian"><code class="name flex">
<span>def <span class="ident">mesh_smooth_laplacian</span></span>(<span>mesh, factor=0.3)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mesh_smooth_laplacian(mesh, factor=0.3):
    smoothed = mesh.copy()
    #smoothed.update_topology()
    for i,v in enumerate(mesh.vertices):
        adjacent_vertices = [e.other_vertex(v) for e in v.edges]
        v_sum = Vertex()
        [v_sum.add(av) for av in adjacent_vertices]
        v_sum.divide(len(adjacent_vertices))
        delta = v_sum - v
        sv = smoothed.vertices[i]
        delta.scale(factor)
        sv.add(delta)
    return smoothed</code></pre>
</details>
</dd>
<dt id="mola.normal_edge_2d"><code class="name flex">
<span>def <span class="ident">normal_edge_2d</span></span>(<span>vprev, v)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal_edge_2d(vprev, v):
    vec1 = utils_vertex.vertex_subtract(v, vprev)
    vec1 = utils_vertex.vertex_unitize(vec1)
    return utils_vertex.vertex_rotate_2D_90(vec1)</code></pre>
</details>
</dd>
<dt id="mola.normal_edge_2d_non_unified"><code class="name flex">
<span>def <span class="ident">normal_edge_2d_non_unified</span></span>(<span>vprev, v)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal_edge_2d_non_unified(vprev, v):
    vec1 = utils_vertex.vertex_subtract(v, vprev)
    return utils_vertex.vertex_rotate_2D_90(vec1)</code></pre>
</details>
</dd>
<dt id="mola.normal_vertex_2d"><code class="name flex">
<span>def <span class="ident">normal_vertex_2d</span></span>(<span>vprev, v, vnext)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal_vertex_2d(vprev, v, vnext):
    vec1 = utils_vertex.vertex_subtract(v, vprev)
    vec1 = utils_vertex.vertex_unitize(vec1)
    vec2 = utils_vertex.vertex_subtract(vnext, v)
    vec2 = utils_vertex.vertex_unitize(vec2)
    n = utils_vertex.vertex_add(vec1, vec2)
    n = utils_vertex.vertex_scale(n, 0.5)
    n = utils_vertex.vertex_rotate_2D_90(n)
    #t=n.x
    #n.x=-n.y
    #n.y=t
    return n</code></pre>
</details>
</dd>
<dt id="mola.offset"><code class="name flex">
<span>def <span class="ident">offset</span></span>(<span>mesh, offset=1, doclose=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offset(mesh,offset=1,doclose=True):
    newMesh=Mesh()
    # calculate vertex normals
    for vertex in mesh.vertices:
        vertex.vertex = Vertex(0,0,0)
        vertex.nfaces = 0
    for face in mesh.faces:
        normal = utils_face.face_normal(face)
        for vertex in face.vertices:
            vertex.vertex.add(normal)
            vertex.nfaces += 1
    for vertex in mesh.vertices:
        vertex.vertex.scale(offset / vertex.nfaces)
        vertex.vertex.add(vertex)
    # create faces
    for face in mesh.faces:
        offsetVertices = []
        for vertex in face.vertices:
            offsetVertices.append(vertex.vertex)
        offsetVertices.reverse()
        newFace = Face(offsetVertices)
        newMesh.faces.append(newFace)
        newMesh.faces.append(face)
    # create sides
    if doclose:
        for edge in mesh.edges:
            if edge.face1 == None or edge.face2 == None:
                offsetVertices = [edge.v1, edge.v2, edge.v2.vertex, edge.v1.vertex]
                if edge.face2 == None:
                    offsetVertices.reverse()
                newFace = Face(offsetVertices)
                newMesh.faces.append(newFace)
    newMesh.update_topology()
    return newMesh</code></pre>
</details>
</dd>
<dt id="mola.slice"><code class="name flex">
<span>def <span class="ident">slice</span></span>(<span>mesh, z)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice(mesh,z):
    edges=[]
    for face in mesh.faces:
        if len(face.vertices)==4:
            edge=sliceTriangle((face.vertices[0],face.vertices[1],face.vertices[2]),z)
            if edge!=None:
                edges.append(edge)
            edge=sliceTriangle((face.vertices[2],face.vertices[3],face.vertices[0]),z)
            if edge!=None:
                edges.append(edge)
        if len(face.vertices)==3:
            edge=sliceTriangle(face.vertices,z)
            if edge!=None:
                edges.append(edge)
    return edges</code></pre>
</details>
</dd>
<dt id="mola.sliceTriangle"><code class="name flex">
<span>def <span class="ident">sliceTriangle</span></span>(<span>_vertices, z)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sliceTriangle(_vertices,z):
    intersections=[]
    vPrev=_vertices[-1]
    for v in _vertices:
        intersection=sliceWithZ(vPrev,v,z)
        if intersection!=None:
            intersections.append(intersection)
        vPrev=v
    if len(intersections)==2:
        dX=intersections[0].x-intersections[1].x
        dY=intersections[0].y-intersections[1].y
        if dX!=0 or dY!=0:
            return Edge(intersections[0],intersections[1])
    return None</code></pre>
</details>
</dd>
<dt id="mola.sliceWithZ"><code class="name flex">
<span>def <span class="ident">sliceWithZ</span></span>(<span>v1, v2, z)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sliceWithZ(v1,v2,z):
    if v1.z==z: return Vertex(v1.x,v1.y,z)
    if v1.z&lt;=z and v2.z&lt;=z:
        return None
    if v1.z&gt;=z and v2.z&gt;=z:
        return None
    dX=v2.x-v1.x
    dY=v2.y-v1.y
    dZ=v2.z-v1.z
    if dZ==0:return None
    f=(z-v1.z)/dZ
    return Vertex(f*dX+v1.x,f*dY+v1.y,z)</code></pre>
</details>
</dd>
<dt id="mola.subdivide_catmull_2d"><code class="name flex">
<span>def <span class="ident">subdivide_catmull_2d</span></span>(<span>vertices)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_catmull_2d(vertices):
    newNodes = []
    for i in range(len(vertices)):
        a = vertices[i]
        newNodes.append(Vertex(a.x,a.y,a.z))
        b = vertices[(i + 1) % len(vertices)]
        center = utils_vertex.vertex_add(a, b)
        newNodes.append(utils_vertex.vertex_scale(center,0.5))
    newNodes2 = []
    for i in range(len(newNodes)):
        iPrev = i - 1
        if iPrev &lt; 0:
            iPrev = len(newNodes) - 1
        iNext = i + 1
        if iNext &gt;= len(newNodes):
            iNext = 0
        a = newNodes[iPrev]
        b = newNodes[i]
        c = newNodes[iNext]
        average = Vertex()
        # [average.add(v) for v in [a,b,b,c]]
        average.add(a)
        average.add(b)
        average.add(b)
        average.add(c)
        average.divide(4.0)
        # average = utils_vertex.vertex_add(average,a)
        # average = utils_vertex.vertex_add(average,b)
        # average = utils_vertex.vertex_add(average,b)
        # average = utils_vertex.vertex_add(average,c)
        # average /= 4
        # average = utils_vertex.vertex_divide(average,4.0)
        newNodes2.append(average)
    return newNodes2</code></pre>
</details>
</dd>
<dt id="mola.subdivide_custom_triface_extrude_tapered_nonU"><code class="name flex">
<span>def <span class="ident">subdivide_custom_triface_extrude_tapered_nonU</span></span>(<span>face, height=0.0, fraction=0.5, doCap=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Extrudes a triangular face tapered like a window by creating an
offset face and quads between every original edge and the
corresponding new edge. The vertices of the new edge which corresponds
to the shortest edge of the triangle are moved closer to the later,
while preserving the offset from its other edges </p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.core.Face
The face to be extruded
height : float
The distance of the new face to the original face, default 0
fraction : float
The relative offset distance, 0: original vertex, 1: center point
default 0.5 (halfway)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_custom_triface_extrude_tapered_nonU(face, height=0.0, fraction=0.5,doCap=True):
    &#34;&#34;&#34;
    Extrudes a triangular face tapered like a window by creating an
    offset face and quads between every original edge and the
    corresponding new edge. The vertices of the new edge which corresponds 
    to the shortest edge of the triangle are moved closer to the later,
    while preserving the offset from its other edges 

    Arguments:
    ----------
    face : mola.core.Face
        The face to be extruded
    height : float
        The distance of the new face to the original face, default 0
    fraction : float
        The relative offset distance, 0: original vertex, 1: center point
        default 0.5 (halfway)
    &#34;&#34;&#34;

    center_vertex = utils_face.face_center(face)
    normal = utils_face.face_normal(face)
    scaled_normal = utils_vertex.vertex_scale(normal, height)

    minD = 9999999999999999
    for i in range(len(face.vertices)-1):
        n1 = face.vertices[i]
        for j in range(i+1,len(face.vertices)):

            n2 = face.vertices[j]
            d = (n2.x-n1.x)**2.0 + (n2.y - n1.y)**2.0 + (n2.z - n1.z)**2.0
            if d&lt;minD:
                minD = d
                shortF_st = i
                shortF_end = j

    other = 3 - shortF_st - shortF_end
    n_other = face.vertices[other]
    betw_other = utils_vertex.vertex_subtract(center_vertex, n_other)
    betw_other = utils_vertex.vertex_scale(betw_other, fraction)
    nn_other = utils_vertex.vertex_add(n_other, betw_other)
    nn_other = utils_vertex.vertex_add(nn_other, scaled_normal)

    # calculate new vertex positions
    new_vertices = []
    for i in range(len(face.vertices)):
        n1 = face.vertices[i]
        betw = utils_vertex.vertex_subtract(center_vertex, n1)
        betw = utils_vertex.vertex_scale(betw, fraction)
        nn = utils_vertex.vertex_add(n1, betw)
        nn = utils_vertex.vertex_add(nn, scaled_normal) 

        if i==shortF_st or i==shortF_end:
            vec = utils_vertex.vertex_subtract(n1, nn_other)
            vec = utils_vertex.vertex_scale(vec, 0.25)
            nn = utils_vertex.vertex_add(nn, vec)

        new_vertices.append(nn)

    new_faces = []
    # create the quads along the edges
    num = len(face.vertices)
    for i in range(num):
        n1 = face.vertices[i]
        n2 = face.vertices[(i + 1) % num]
        n3 = new_vertices[(i + 1) % num]
        n4 = new_vertices[i]
        new_face = Face([n1,n2,n3,n4])
        new_faces.append(new_face)

    # create the closing cap face
    if doCap:
        cap_face = Face(new_vertices)
        new_faces.append(cap_face)

    for new_face in new_faces:
        utils_face.face_copy_properties(face,new_face)

    return new_faces</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_extrude"><code class="name flex">
<span>def <span class="ident">subdivide_face_extrude</span></span>(<span>face, height=0.0, capBottom=False, capTop=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Extrudes the face straight by distance height.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.core.Face
The face to be extruded
height : float
The extrusion distance, default 0
capBottom : bool
Toggle if bottom face (original face) should be created, default False
capTop : bool
Toggle if top face (extrusion face) should be created, default True</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_extrude(face, height=0.0, capBottom=False, capTop=True):
    &#34;&#34;&#34;
    Extrudes the face straight by distance height.

    Arguments:
    ----------
    face : mola.core.Face
        The face to be extruded
    height : float
        The extrusion distance, default 0
    capBottom : bool
        Toggle if bottom face (original face) should be created, default False
    capTop : bool
        Toggle if top face (extrusion face) should be created, default True
    &#34;&#34;&#34;
    normal=utils_face.face_normal(face)
    normal=utils_vertex.vertex_scale(normal,height)
    # calculate vertices
    new_vertices=[]
    for i in range(len(face.vertices)):
        new_vertices.append(utils_vertex.vertex_add(face.vertices[i], normal))
    # faces
    new_faces=[]
    if capBottom:
        new_faces.append(face)
    for i in range(len(face.vertices)):
        i2=i+1
        if i2&gt;=len(face.vertices):
            i2=0
        v0=face.vertices[i]
        v1=face.vertices[i2]
        v2=new_vertices[i2]
        v3=new_vertices[i]
        new_faces.append(Face([v0,v1,v2,v3]))
    if capTop:
        new_faces.append(Face(new_vertices))
    for new_face in new_faces:
        utils_face.face_copy_properties(face,new_face)
    return new_faces</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_extrude_tapered"><code class="name flex">
<span>def <span class="ident">subdivide_face_extrude_tapered</span></span>(<span>face, height=0.0, fraction=0.5, doCap=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Extrudes the face tapered like a window by creating an
offset face and quads between every original edge and the
corresponding new edge.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.core.Face
The face to be extruded
height : float
The distance of the new face to the original face, default 0
fraction : float
The relative offset distance, 0: original vertex, 1: center point
default 0.5 (halfway)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_extrude_tapered(face, height=0.0, fraction=0.5,doCap=True):
    &#34;&#34;&#34;
    Extrudes the face tapered like a window by creating an
    offset face and quads between every original edge and the
    corresponding new edge.

    Arguments:
    ----------
    face : mola.core.Face
        The face to be extruded
    height : float
        The distance of the new face to the original face, default 0
    fraction : float
        The relative offset distance, 0: original vertex, 1: center point
        default 0.5 (halfway)
    &#34;&#34;&#34;
    center_vertex = utils_face.face_center(face)
    normal = utils_face.face_normal(face)
    scaled_normal = utils_vertex.vertex_scale(normal, height)

    # calculate new vertex positions
    new_vertices = []
    for i in range(len(face.vertices)):
        n1 = face.vertices[i]
        betw = utils_vertex.vertex_subtract(center_vertex, n1)
        betw = utils_vertex.vertex_scale(betw, fraction)
        nn = utils_vertex.vertex_add(n1, betw)
        nn = utils_vertex.vertex_add(nn, scaled_normal)
        new_vertices.append(nn)

    new_faces = []
    # create the quads along the edges
    num = len(face.vertices)
    for i in range(num):
        n1 = face.vertices[i]
        n2 = face.vertices[(i + 1) % num]
        n3 = new_vertices[(i + 1) % num]
        n4 = new_vertices[i]
        new_face = Face([n1,n2,n3,n4])
        new_faces.append(new_face)

    # create the closing cap face
    if doCap:
        cap_face = Face(new_vertices)
        new_faces.append(cap_face)

    for new_face in new_faces:
        utils_face.face_copy_properties(face,new_face)
    return new_faces</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_extrude_to_point"><code class="name flex">
<span>def <span class="ident">subdivide_face_extrude_to_point</span></span>(<span>face, point)</span>
</code></dt>
<dd>
<section class="desc"><p>Extrudes the face to a point by creating a
triangular face from each edge to the point.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.core.Face
The face to be extruded
point : mola.core.Vertex
The point to extrude to</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_extrude_to_point(face, point):
    &#34;&#34;&#34;
    Extrudes the face to a point by creating a
    triangular face from each edge to the point.

    Arguments:
    ----------
    face : mola.core.Face
        The face to be extruded
    point : mola.core.Vertex
        The point to extrude to
    &#34;&#34;&#34;
    numV = len(face.vertices)
    faces = []
    for i in range(numV):
        v1 = face.vertices[i]
        v2 = face.vertices[(i + 1) % numV]
        f = Face([v1, v2, point])
        utils_face.face_copy_properties(face, f)
        faces.append(f)
    return faces</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_extrude_to_point_center"><code class="name flex">
<span>def <span class="ident">subdivide_face_extrude_to_point_center</span></span>(<span>face, height=0.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Extrudes the face to the center point moved by height
normal to the face and creating a triangular face from
each edge to the point.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.core.Face
The face to be extruded
height : float
The distance of the new point to the face center, default 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_extrude_to_point_center(face, height=0.0):
    &#34;&#34;&#34;
    Extrudes the face to the center point moved by height
    normal to the face and creating a triangular face from
    each edge to the point.

    Arguments:
    ----------
    face : mola.core.Face
        The face to be extruded
    height : float
        The distance of the new point to the face center, default 0
    &#34;&#34;&#34;
    normal = utils_face.face_normal(face)
    normal = utils_vertex.vertex_scale(normal,height)
    center = utils_face.face_center(face)
    center = utils_vertex.vertex_add(center,normal)
    return subdivide_face_extrude_to_point(face,center)</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_offset_planar"><code class="name flex">
<span>def <span class="ident">subdivide_face_offset_planar</span></span>(<span>face, offsets)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_offset_planar(face,offsets):
    newPts = []
    for i in range(len(face.vertices)):
        iP = i - 1
        if(iP &lt; 0):
            iP = len(face.vertices)-1
        iN = (i + 1) % len(face.vertices)
        v0 = face.vertices[iP]
        v1 = face.vertices[i]
        v2 = face.vertices[iN]
        newPts.append(utils_vertex.vertex_offset_point(v0, v1, v2, offsets[iP], offsets[i]))
    f = Face(newPts)
    utils_face.face_copy_properties(face, f)
    return f</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_split_frame"><code class="name flex">
<span>def <span class="ident">subdivide_face_split_frame</span></span>(<span>face, w)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates an offset frame with quad corners. Works only with convex shapes.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.core.Face
The face to be split
w : float
The width of the offset frame</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_split_frame(face, w):
    &#34;&#34;&#34;
    Creates an offset frame with quad corners. Works only with convex shapes.

    Arguments:
    ----------
    face : mola.core.Face
        The face to be split
    w : float
        The width of the offset frame
    &#34;&#34;&#34;
    faces = []
    innerVertices = []
    for i in range(len(face.vertices)):
      if(i == 0):
        vp = face.vertices[len(face.vertices)-1]
      else:
        vp = face.vertices[i - 1]
      v = face.vertices[i]
      vn = face.vertices[(i + 1) % len(face.vertices)]
      vnn = face.vertices[(i + 2) % len(face.vertices)]

      th1 = utils_vertex.vertex_angle_triangle(vp,v,vn)
      th2 = utils_vertex.vertex_angle_triangle(v,vn,vnn)

      w1 = w / math.sin(th1)
      w2 = w / math.sin(th2)

      vs1 = _vertices_frame(v, vn, w1, w2)
      vs2 = _vertices_frame(_vertices_frame(vp, v, w1, w1)[2], _vertices_frame(vn, vnn, w2, w2)[1], w1, w2)
      innerVertices.append(vs2[1])
      f1 = Face([vs1[0], vs2[0], vs2[1], vs1[1]])
      utils_face.face_copy_properties(face, f1)
      f2 = Face([vs1[1], vs2[1], vs2[2], vs1[2]])
      utils_face.face_copy_properties(face, f2)
      faces.extend([f1, f2])
    fInner = Face(innerVertices)
    utils_face.face_copy_properties(face, fInner)
    faces.append(fInner)
    return faces</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_split_grid"><code class="name flex">
<span>def <span class="ident">subdivide_face_split_grid</span></span>(<span>face, nU, nV)</span>
</code></dt>
<dd>
<section class="desc"><p>splits a triangle, quad or a rectangle into a regular grid</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_split_grid(face,nU,nV):
    &#34;&#34;&#34;
    splits a triangle, quad or a rectangle into a regular grid
    &#34;&#34;&#34;
    if len(face.vertices) &gt; 4:
        print(&#39;too many vertices&#39;)
        return face

    if len(face.vertices) == 4:
        vsU1 = _vertices_between(face.vertices[0], face.vertices[1], nU)
        vsU2 = _vertices_between(face.vertices[3], face.vertices[2], nU)
        gridVertices = []
        for u in range(len(vsU1)):
            gridVertices.append(_vertices_between(vsU1[u], vsU2[u], nV))
        faces = []
        for u in range(len(vsU1) - 1):
            vs1 = gridVertices[u]
            vs2 = gridVertices[u + 1]
            for v in range(len(vs1) - 1):
                #f = Face([vs1[v], vs1[v + 1], vs2[v + 1], vs2[v]])
                f = Face([vs1[v], vs2[v], vs2[v + 1], vs1[v + 1]])
                utils_face.face_copy_properties(face, f)
                faces.append(f)
        return faces

    if len(face.vertices) == 3:
        vsU1 = _vertices_between(face.vertices[0], face.vertices[1], nU)
        vsU2 = _vertices_between(face.vertices[0], face.vertices[2], nU)
        gridVertices = []
        for u in range(1, len(vsU1)):
            gridVertices.append(_vertices_between(vsU1[u], vsU2[u], nV))
        faces = []
        # triangles
        v0 = face.vertices[0]
        vs1 = gridVertices[0]
        for v in range(len(vs1) - 1):
            f = Face([v0,vs1[v],vs1[v + 1]])
            utils_face.face_copy_properties(face, f)
            faces.append(f)
        for u in range(len(gridVertices) - 1):
            vs1 = gridVertices[u]
            vs2 = gridVertices[u + 1]
            for v in range(len(vs1) - 1):
                f = Face([vs1[v],vs1[v + 1], vs2[v + 1], vs2[v]])
                utils_face.face_copy_properties(face, f)
                faces.append(f)
        return faces</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_split_offset"><code class="name flex">
<span>def <span class="ident">subdivide_face_split_offset</span></span>(<span>face, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_split_offset(face,offset):
    offsets = [offset] * len(face.vertices)
    return subdivide_face_split_offsets(face, offsets)</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_split_offsets"><code class="name flex">
<span>def <span class="ident">subdivide_face_split_offsets</span></span>(<span>face, offsets)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_split_offsets(face,offsets):
    offsetFace = subdivide_face_offset_planar(face,offsets)
    nOffsetFaces = 0
    for o in offsets:
        if(abs(o) &gt; 0):
            nOffsetFaces += 1
    faces = []
    for i in range(len(face.vertices)):
        if(abs(offsets[i]) &gt; 0):
            i2 = (i + 1) % len(face.vertices)
            f = Face([face.vertices[i], face.vertices[i2], offsetFace.vertices[i2], offsetFace.vertices[i]])
            utils_face.face_copy_properties(face, f)
            faces.append(f)
    faces.append(offsetFace)
    for f in faces:
        if(utils_face.face_area(f) &lt; 0):
            f.vertices.reverse()
    return faces</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_split_rel"><code class="name flex">
<span>def <span class="ident">subdivide_face_split_rel</span></span>(<span>face, direction, split)</span>
</code></dt>
<dd>
<section class="desc"><p>Splits face in given direction.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.core.Face
The face to be split
direction : integer (-1 or 0)
split : float
Position of the split relative to initial face points (0 to 1)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_split_rel(face, direction, split):
    &#34;&#34;&#34;
    Splits face in given direction.

    Arguments:
    ----------
    face : mola.core.Face
        The face to be split
    direction : integer (-1 or 0)
    split : float
        Position of the split relative to initial face points (0 to 1)
    &#34;&#34;&#34;
    return subdivide_face_split_rel_multiple(face, direction, [split])</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_split_rel_free_quad"><code class="name flex">
<span>def <span class="ident">subdivide_face_split_rel_free_quad</span></span>(<span>face, indexEdge, split1, split2)</span>
</code></dt>
<dd>
<section class="desc"><p>Splits a quad in two new quads through the points specified
by relative position along the edge.</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.core.Face
The face to be extruded
indexEdge : int
direction of split, 0: 0-&gt;2, 1: 1-&gt;3
split1, split2 : float
relative position of split on each edge (0..1)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_split_rel_free_quad(face, indexEdge,  split1,  split2):
    &#34;&#34;&#34;
    Splits a quad in two new quads through the points specified
    by relative position along the edge.

    Arguments:
    ----------
    face : mola.core.Face
        The face to be extruded
    indexEdge : int
        direction of split, 0: 0-&gt;2, 1: 1-&gt;3
    split1, split2 : float
        relative position of split on each edge (0..1)
    &#34;&#34;&#34;
    # only works with quads, therefore return original face if triangular
    if len(face.vertices) != 4:
        return face

    # constrain indexEdge to be either 0 or 1
    indexEdge = indexEdge%2

    indexEdge1 = (indexEdge + 1) % len(face.vertices)
    indexEdge2 = (indexEdge + 2) % len(face.vertices)
    indexEdge3 = (indexEdge + 3) % len(face.vertices)
    p1 = utils_vertex.vertex_between_rel(face.vertices[indexEdge], face.vertices[indexEdge1], split1)
    p2 = utils_vertex.vertex_between_rel(face.vertices[indexEdge2 ], face.vertices[indexEdge3], split2)
    faces = []
    if indexEdge == 0:
        f1 = Face([face.vertices[0], p1, p2, face.vertices[3]])
        f2 = Face([p1, face.vertices[1], face.vertices[2], p2])
        utils_face.face_copy_properties(face, f1)
        utils_face.face_copy_properties(face, f2)
        faces.extend([f1, f2])
    elif indexEdge == 1:
        f1 = Face([face.vertices[0], face.vertices[1], p1, p2])
        f2 = Face([p2, p1, face.vertices[2], face.vertices[3]])
        utils_face.face_copy_properties(face,f1)
        utils_face.face_copy_properties(face,f2)
        faces.extend([f1, f2])
    return faces</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_split_rel_multiple"><code class="name flex">
<span>def <span class="ident">subdivide_face_split_rel_multiple</span></span>(<span>face, direction, splits)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_split_rel_multiple(face, direction, splits):
    sA = []
    sA.append(face.vertices[direction])
    lA = face.vertices[direction + 1]
    sB = []
    sB.append(face.vertices[direction + 3])
    lB = face.vertices[(direction + 2) % len(face.vertices)]

    for i in range(len(splits)):
        sA.append(utils_vertex.vertex_between_rel(sA[0], lA,splits[i]))
        sB.append(utils_vertex.vertex_between_rel(sB[0], lB,splits[i]))
    sA.append(lA)
    sB.append(lB)

    result = []
    for i in range(len(splits) + 1):
        if(dir == 1):
            f = Face([sB[i], sA[i], sA[i+1], sB[i+1]])
            utils_face.face_copy_properties(face, f)
            result.append(f)
        else:
            f = Face([sB[i], sB[i+1], sA[i+1], sA[i]])
            utils_face.face_copy_properties(face, f)
            result.append(f)
    return result</code></pre>
</details>
</dd>
<dt id="mola.subdivide_face_split_roof"><code class="name flex">
<span>def <span class="ident">subdivide_face_split_roof</span></span>(<span>face, height)</span>
</code></dt>
<dd>
<section class="desc"><p>Extrudes a pitched roof</p>
<h2 id="arguments">Arguments:</h2>
<p>face : mola.core.Face
The face to be extruded
height : mola.core.Vertex
Th height of the roof</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_face_split_roof(face, height):
    &#34;&#34;&#34;
    Extrudes a pitched roof

    Arguments:
    ----------
    face : mola.core.Face
        The face to be extruded
    height : mola.core.Vertex
        Th height of the roof
    &#34;&#34;&#34;
    faces = []
    normal = utils_face.face_normal(face)
    normal = utils_vertex.vertex_scale(normal,height)
    if len(face.vertices) == 4:
        ev1 = utils_vertex.vertex_center(face.vertices[0], face.vertices[1])
        ev1 = utils_vertex.vertex_add(ev1, normal)
        ev2 = utils_vertex.vertex_center(face.vertices[2], face.vertices[3])
        ev2 = utils_vertex.vertex_add(ev2, normal)

        faces.append(Face([face.vertices[0], face.vertices[1], ev1]))
        faces.append(Face([face.vertices[1], face.vertices[2], ev2, ev1]))
        faces.append(Face([face.vertices[2], face.vertices[3], ev2]))
        faces.append(Face([face.vertices[3], face.vertices[0], ev1, ev2]))

        for f in faces:
            utils_face.face_copy_properties(face,f)
        return faces

    elif len(face.vertices) == 3:
        ev1 = utils_vertex.vertex_center(face.vertices[0], face.vertices[1])
        ev1 = utils_vertex.vertex_add(ev1, normal)
        ev2 = utils_vertex.vertex_center(face.vertices[1], face.vertices[2])
        ev2 = utils_vertex.vertex_add(ev2, normal)

        faces.append(Face([face.vertices[0], face.vertices[1], ev1]))
        faces.append(Face([face.vertices[1], ev2, ev1]))
        faces.append(Face([face.vertices[1], face.vertices[2], ev2]))
        faces.append(Face([face.vertices[2], face.vertices[0], ev1, ev2]))

        for f in faces:
            utils_face.face_copy_properties(face, f)
        return faces
    return [face]</code></pre>
</details>
</dd>
<dt id="mola.subdivide_mesh"><code class="name flex">
<span>def <span class="ident">subdivide_mesh</span></span>(<span>mesh, values=[])</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_mesh(mesh,values=[]):
    for face in mesh.faces:
        face.vertex=utils_face.center(face)
    for edge in mesh.edges:
        edge.vertex = edge.center()
    for vertex in mesh.vertices:
        vertex.vertex = Vertex(vertex.x,vertex.y,vertex.z)
    if len(values)&gt;0:
        _translate_face_vertices(mesh,values)
    return _collect_new_faces(mesh)</code></pre>
</details>
</dd>
<dt id="mola.subdivide_mesh_catmull"><code class="name flex">
<span>def <span class="ident">subdivide_mesh_catmull</span></span>(<span>mesh, values=[])</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_mesh_catmull(mesh, values=[]):
    _catmullVertices(mesh)
    if len(values)&gt;0:
        _translate_face_vertices(mesh,values)
    return _collect_new_faces(mesh)</code></pre>
</details>
</dd>
<dt id="mola.subdivide_mesh_extrude_tapered"><code class="name flex">
<span>def <span class="ident">subdivide_mesh_extrude_tapered</span></span>(<span>mesh, heights, fractions, doCaps)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_mesh_extrude_tapered(mesh,heights,fractions,doCaps):
    new_mesh = Mesh()
    for face,height,fraction,doCap in zip(mesh.faces,heights,fractions,doCaps):
        new_mesh.faces.extend(subdivide_face_extrude_tapered(face,height,fraction,doCap))
    new_mesh.update_topology()
    return new_mesh</code></pre>
</details>
</dd>
<dt id="mola.subdivide_mesh_extrude_to_point_center"><code class="name flex">
<span>def <span class="ident">subdivide_mesh_extrude_to_point_center</span></span>(<span>mesh, heights, doExtrudes)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide_mesh_extrude_to_point_center(mesh,heights,doExtrudes):
    new_mesh = Mesh()
    for face,height,doExtrude in zip(mesh.faces,heights,doExtrudes):
        if doExtrude:
            new_mesh.faces.extend(subdivide_face_extrude_to_point_center(face,height))
        else:
            new_mesh.faces.append(face)
    new_mesh.update_topology()
    return new_mesh</code></pre>
</details>
</dd>
<dt id="mola.triangle_area"><code class="name flex">
<span>def <span class="ident">triangle_area</span></span>(<span>v1, v2, v3)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the area of the triangle from 3 vertices</p>
<h2 id="arguments">Arguments:</h2>
<p>v1, v2, v3 : mola.Vertex
vertices of the triangle</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_area(v1,v2,v3):
    &#34;&#34;&#34;
    Returns the area of the triangle from 3 vertices

    Arguments:
    ----------
    v1, v2, v3 : mola.Vertex
        vertices of the triangle
    &#34;&#34;&#34;
    return triangle_coords_area(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z)</code></pre>
</details>
</dd>
<dt id="mola.triangle_coords_area"><code class="name flex">
<span>def <span class="ident">triangle_coords_area</span></span>(<span>xa, ya, za, xb, yb, zb, xc, yc, zc)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the area of the triangle from 9 coordinates</p>
<h2 id="arguments">Arguments:</h2>
<p>xa, ya, za : float
coordinates of vertex a
xb, yb, zb : float
coordinates of vertex b
xc, yc, zc : float
coordinates of vertex c</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_coords_area(xa, ya, za, xb, yb, zb, xc, yc, zc):
    &#34;&#34;&#34;
    Returns the area of the triangle from 9 coordinates

    Arguments:
    ----------
    xa, ya, za : float
        coordinates of vertex a
    xb, yb, zb : float
        coordinates of vertex b
    xc, yc, zc : float
        coordinates of vertex c
    &#34;&#34;&#34;
    return 0.5 * math.sqrt(math.pow(utils_math.math_determinant(xa, xb, xc, ya, yb, yc, 1, 1, 1), 2) + math.pow(utils_math.math_determinant(ya, yb, yc, za, zb, zc, 1, 1, 1), 2) + math.pow(utils_math.math_determinant(za, zb, zc, xa, xb, xc, 1, 1, 1), 2))</code></pre>
</details>
</dd>
<dt id="mola.triangle_normal"><code class="name flex">
<span>def <span class="ident">triangle_normal</span></span>(<span>v1, v2, v3)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the normal of a triangle defined by 3 vertices.
The normal is a vector of length 1 perpendicular to the plane of the triangle.</p>
<h2 id="arguments">Arguments:</h2>
<p>v1, v2, v3 : mola.Vertex
the vertices get the normal from</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_normal(v1,v2,v3):
    &#34;&#34;&#34;
    Returns the normal of a triangle defined by 3 vertices.
    The normal is a vector of length 1 perpendicular to the plane of the triangle.

    Arguments:
    ----------
    v1, v2, v3 : mola.Vertex
        the vertices get the normal from
    &#34;&#34;&#34;
    v = v2-v1
    u = v3-v1
    crossProduct=vertex_cross(v, u)
    return vertex_unitize(crossProduct)</code></pre>
</details>
</dd>
<dt id="mola.vertex_add"><code class="name flex">
<span>def <span class="ident">vertex_add</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>adds the position vector of v2 to the position vector of v1
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_add(v1,v2):
    &#34;&#34;&#34;
    adds the position vector of v2 to the position vector of v1
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)</code></pre>
</details>
</dd>
<dt id="mola.vertex_angle"><code class="name flex">
<span>def <span class="ident">vertex_angle</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_angle(v1,v2):
    a = vertex_unitize(v1)
    b = vertex_unitize(v2)
    f = vertex_dot(a, b)
    f = min(1, max(-1, f))
    return math.acos(f)</code></pre>
</details>
</dd>
<dt id="mola.vertex_angle_triangle"><code class="name flex">
<span>def <span class="ident">vertex_angle_triangle</span></span>(<span>vPrevious, v, vNext)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_angle_triangle(vPrevious,v,vNext):
    #law of cosines
    vvn = vertex_distance(v, vNext)
    vvp = vertex_distance(vPrevious, v)
    vnvp = vertex_distance(vNext, vPrevious)
    return math.acos((vvn * vvn + vvp * vvp - vnvp * vnvp) / (2 * vvn * vvp))</code></pre>
</details>
</dd>
<dt id="mola.vertex_between_abs"><code class="name flex">
<span>def <span class="ident">vertex_between_abs</span></span>(<span>v1, v2, dis)</span>
</code></dt>
<dd>
<section class="desc"><p>finds a position vector between v1 and v2 by an absolute distance value from v1
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_between_abs(v1, v2, dis):
    &#34;&#34;&#34;
    finds a position vector between v1 and v2 by an absolute distance value from v1
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    d = vertex_distance(v1,v2)
    return vertex_between_rel(v1, v2, dis / d)</code></pre>
</details>
</dd>
<dt id="mola.vertex_between_rel"><code class="name flex">
<span>def <span class="ident">vertex_between_rel</span></span>(<span>v1, v2, factor)</span>
</code></dt>
<dd>
<section class="desc"><p>finds a position vector between v1 and v2 by a factor (0.0 to 1.0 corresponds to v1 to v2)
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_between_rel(v1, v2, factor):
    &#34;&#34;&#34;
    finds a position vector between v1 and v2 by a factor (0.0 to 1.0 corresponds to v1 to v2)
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex((v2.x - v1.x) * factor + v1.x, (v2.y - v1.y) * factor + v1.y, (v2.z - v1.z) * factor + v1.z)</code></pre>
</details>
</dd>
<dt id="mola.vertex_center"><code class="name flex">
<span>def <span class="ident">vertex_center</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the center of a line defined by two vertices.</p>
<h2 id="arguments">Arguments:</h2>
<p>v1, v2 : mola.Vertex
start and end points of the line</p>
<h2 id="returns">Returns:</h2>
<p>mola.Vertex
the center point of the line</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_center(v1,v2):
    &#34;&#34;&#34;
    Returns the center of a line defined by two vertices.

    Arguments:
    ----------
    v1, v2 : mola.Vertex
        start and end points of the line

    Returns:
    --------
    mola.Vertex
        the center point of the line
    &#34;&#34;&#34;

    return Vertex((v1.x+v2.x)/2,(v1.y+v2.y)/2,(v1.z+v2.z)/2)</code></pre>
</details>
</dd>
<dt id="mola.vertex_cross"><code class="name flex">
<span>def <span class="ident">vertex_cross</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the cross product of v1 and v2 as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_cross(v1,v2):
    &#34;&#34;&#34;
    returns the cross product of v1 and v2 as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v1.y * v2.z - v2.y * v1.z, v1.z * v2.x - v2.z * v1.x, v1.x * v2.y - v2.x * v1.y)</code></pre>
</details>
</dd>
<dt id="mola.vertex_distance"><code class="name flex">
<span>def <span class="ident">vertex_distance</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the distance between v1 and v2.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_distance(v1,v2):
    &#34;&#34;&#34;
    returns the distance between v1 and v2.
    &#34;&#34;&#34;
    dX = v2.x - v1.x
    dY = v2.y - v1.y
    dZ = v2.z - v1.z
    return math.sqrt(dX*dX+dY*dY+dZ*dZ)</code></pre>
</details>
</dd>
<dt id="mola.vertex_divide"><code class="name flex">
<span>def <span class="ident">vertex_divide</span></span>(<span>v, factor)</span>
</code></dt>
<dd>
<section class="desc"><p>scales the position vector of a Vertex by a factor (division)
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_divide(v,factor):
    &#34;&#34;&#34;
    scales the position vector of a Vertex by a factor (division)
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v.x / factor, v.y / factor, v.z / factor)</code></pre>
</details>
</dd>
<dt id="mola.vertex_dot"><code class="name flex">
<span>def <span class="ident">vertex_dot</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the dot product of v1 and v2.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_dot(v1,v2):
    &#34;&#34;&#34;
    returns the dot product of v1 and v2.
    &#34;&#34;&#34;
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z</code></pre>
</details>
</dd>
<dt id="mola.vertex_length"><code class="name flex">
<span>def <span class="ident">vertex_length</span></span>(<span>v)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the length of the position vector of a Vertex,
the distance from the origin (0,0,0).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_length(v):
    &#34;&#34;&#34;
    returns the length of the position vector of a Vertex,
    the distance from the origin (0,0,0).
    &#34;&#34;&#34;
    return math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)</code></pre>
</details>
</dd>
<dt id="mola.vertex_line_line_intersection"><code class="name flex">
<span>def <span class="ident">vertex_line_line_intersection</span></span>(<span>a, b, c, d)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the intersection of two lines in 2D as a new Vertex.</p>
<h2 id="arguments">Arguments:</h2>
<p>a,b,c,d: mola.Vertex
a,b are the endpoints of line1
c,d are the endpoints of line2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_line_line_intersection(a,b,c,d):
    &#34;&#34;&#34;
    Returns the intersection of two lines in 2D as a new Vertex.

    Arguments:
    ----------
    a,b,c,d: mola.Vertex
             a,b are the endpoints of line1
             c,d are the endpoints of line2
    &#34;&#34;&#34;
    deltaABX = b.x - a.x
    deltaABY = b.y - a.y
    deltaDCX = d.x - c.x
    deltaDCY = d.y - c.y
    denominator = deltaABX * deltaDCY - deltaABY * deltaDCX
    if denominator == 0:
        return None
    numerator = (a.y - c.y) * deltaDCX - (a.x - c.x) * deltaDCY
    r = numerator / denominator
    x = a.x + r * deltaABX
    y = a.y + r * deltaABY
    return Vertex(x,y,0)</code></pre>
</details>
</dd>
<dt id="mola.vertex_offset_line"><code class="name flex">
<span>def <span class="ident">vertex_offset_line</span></span>(<span>v1, v2, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_offset_line(v1, v2, offset):
    v = vertex_subtract(v2, v1)
    v = vertex_unitize(v)
    v = vertex_scale(v,offset)
    t = v.x
    v.x = -v.y
    v.y = t
    v.z = 0
    return Vertex(vertex_add(v1, v), vertex_add(v2, v))</code></pre>
</details>
</dd>
<dt id="mola.vertex_offset_point"><code class="name flex">
<span>def <span class="ident">vertex_offset_point</span></span>(<span>v1, v2, v3, offset1, offset2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_offset_point(v1, v2, v3, offset1, offset2):
    line1 = vertex_offset_line(v1, v2, offset1)
    line2 = vertex_offset_line(v2, v3, offset2)
    return vertex_line_line_intersection(line1.x,line1.y,line2.x,line2.y)</code></pre>
</details>
</dd>
<dt id="mola.vertex_rotate_2D_90"><code class="name flex">
<span>def <span class="ident">vertex_rotate_2D_90</span></span>(<span>vertex)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_rotate_2D_90(vertex):
    return Vertex(-vertex.y, vertex.x, vertex.z)</code></pre>
</details>
</dd>
<dt id="mola.vertex_scale"><code class="name flex">
<span>def <span class="ident">vertex_scale</span></span>(<span>v, factor)</span>
</code></dt>
<dd>
<section class="desc"><p>scales the position vector of a Vertex by a factor (multiplication)
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_scale(v,factor):
    &#34;&#34;&#34;
    scales the position vector of a Vertex by a factor (multiplication)
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v.x * factor, v.y * factor, v.z * factor)</code></pre>
</details>
</dd>
<dt id="mola.vertex_subtract"><code class="name flex">
<span>def <span class="ident">vertex_subtract</span></span>(<span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"><p>subtracts the position vector of v2 from the position vector of v1
and returns the result as a new Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_subtract(v1,v2):
    &#34;&#34;&#34;
    subtracts the position vector of v2 from the position vector of v1
    and returns the result as a new Vertex.
    &#34;&#34;&#34;
    return Vertex(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)</code></pre>
</details>
</dd>
<dt id="mola.vertex_unitize"><code class="name flex">
<span>def <span class="ident">vertex_unitize</span></span>(<span>v)</span>
</code></dt>
<dd>
<section class="desc"><p>returns a Vertex of the same direction
and of unit length 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_unitize(v):
    &#34;&#34;&#34;
    returns a Vertex of the same direction
    and of unit length 1
    &#34;&#34;&#34;
    l = vertex_length(v)
    if l == 0:
        return v
    return vertex_scale(v,1/l)</code></pre>
</details>
</dd>
<dt id="mola.vertices_list_area"><code class="name flex">
<span>def <span class="ident">vertices_list_area</span></span>(<span>vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the area of a face from a list of 3 or 4 vertices</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertices_list_area(vertices):
    &#34;&#34;&#34;
    Returns the area of a face from a list of 3 or 4 vertices
    &#34;&#34;&#34;
    if len(vertices) == 3:
        return triangle_area(vertices[0],vertices[1],vertices[2])
    # could be made generic for n-gons, triangle fan?
    elif len(vertices) == 4:
        a1 = triangle_area(vertices[0], vertices[1], vertices[2])
        a2 = triangle_area(vertices[2], vertices[3], vertices[0])
        return a1 + a2</code></pre>
</details>
</dd>
<dt id="mola.vertices_list_center"><code class="name flex">
<span>def <span class="ident">vertices_list_center</span></span>(<span>vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the center point (type Vertex) of a list of vertices.
Note: not the center of gravity, just the average of the vertices.</p>
<h2 id="arguments">Arguments:</h2>
<p>vertices : list of mola.Vertex
The list of vertices to be measured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertices_list_center(vertices):
    &#34;&#34;&#34;
    Returns the center point (type Vertex) of a list of vertices.
    Note: not the center of gravity, just the average of the vertices.

    Arguments:
    ----------
    vertices : list of mola.Vertex
            The list of vertices to be measured
    &#34;&#34;&#34;
    n = len(vertices)
    cx = sum([v.x for v in vertices]) / n
    cy = sum([v.y for v in vertices]) / n
    cz = sum([v.z for v in vertices]) / n
    return Vertex(cx,cy,cz)</code></pre>
</details>
</dd>
<dt id="mola.vertices_list_normal"><code class="name flex">
<span>def <span class="ident">vertices_list_normal</span></span>(<span>vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the normal of a triangle defined by 3 vertices.
The normal is a vector of length 1 perpendicular to the plane of the triangle.</p>
<h2 id="arguments">Arguments:</h2>
<p>vertices : list
the list of vertices get the normal from (first 3 will be used)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertices_list_normal(vertices):
    &#34;&#34;&#34;
    Returns the normal of a triangle defined by 3 vertices.
    The normal is a vector of length 1 perpendicular to the plane of the triangle.

    Arguments:
    ----------
    vertices : list
        the list of vertices get the normal from (first 3 will be used)
    &#34;&#34;&#34;
    return normalFromTriangle(vertices[0], vertices[1], vertices[2])</code></pre>
</details>
</dd>
<dt id="mola.weldVertices"><code class="name flex">
<span>def <span class="ident">weldVertices</span></span>(<span>edges)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weldVertices(edges):
    dictVertices={}
    for edge in edges:
        tuple=(edge.v1.x,edge.v1.y)
        if tuple in dictVertices:
            edge.v1=dictVertices[tuple]
        else:
            dictVertices[tuple]=edge.v1
        edge.v1.edges.append(edge)

        tuple=(edge.v2.x,edge.v2.y)
        if tuple in dictVertices:
            edge.v2=dictVertices[tuple]
        else:
            dictVertices[tuple]=edge.v2
        edge.v2.edges.append(edge)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mola.Box"><code class="flex name class">
<span>class <span class="ident">Box</span></span>
<span>(</span><span>x1=inf, y1=inf, z1=inf, x2=-inf, y2=-inf, z2=-inf)</span>
</code></dt>
<dd>
<section class="desc"><p>A <a title="mola.Box" href="#mola.Box"><code>Box</code></a> is defined by by two opposite corners with x,y,z coordinates.
Mostly used for getting the bounding box of a set of points.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x1</code></strong>, <strong><code>y1</code></strong>, <strong><code>z1</code></strong> :&ensp;<code>float</code></dt>
<dd>The coordinates of the bottom left front corner.</dd>
<dt><strong><code>x2</code></strong>, <strong><code>y2</code></strong>, <strong><code>z2</code></strong> :&ensp;<code>float</code></dt>
<dd>The coordinates of the top right back corner.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Box:
    &#34;&#34;&#34;A `Box` is defined by by two opposite corners with x,y,z coordinates.
    Mostly used for getting the bounding box of a set of points.

    Attributes
    ----------
    x1, y1, z1 : float
        The coordinates of the bottom left front corner.
    x2, y2, z2 : float
        The coordinates of the top right back corner.
    &#34;&#34;&#34;
    def __init__(self, x1=float(&#39;inf&#39;), y1=float(&#39;inf&#39;), z1=float(&#39;inf&#39;), x2=-float(&#39;inf&#39;), y2=-float(&#39;inf&#39;), z2=-float(&#39;inf&#39;)):
        self.x1 = x1
        self.y1 = y1
        self.z1 = z1
        self.x2 = x2
        self.y2 = y2
        self.z2 = z2

    def dim_x(self):
        &#34;&#34;&#34;
        Returns the Box&#39;s extent in X direction.
        &#34;&#34;&#34;
        return self.x2 - self.x1

    def dim_y(self):
        &#34;&#34;&#34;
        Returns the Box&#39;s extent in Y direction.
        &#34;&#34;&#34;
        return self.y2 - self.y1

    def dim_z(self):
        &#34;&#34;&#34;
        Returns the Box&#39;s extent in Z direction.
        &#34;&#34;&#34;
        return self.z2 - self.z1

    def center(self):
        &#34;&#34;&#34;
        returns the Box&#39;s center as a Vertex() object
        &#34;&#34;&#34;
        return Vertex((self.x2+self.x1)/2.0,(self.y2+self.y1)/2.0,(self.z2+self.z1)/2.0)

    def add_point(self,x,y,z):
        &#34;&#34;&#34;
        adds a point to the bounding box,
        increases the box&#39;s size if the point is outside.
        &#34;&#34;&#34;
        self.x1 = min(x,self.x1)
        self.y1 = min(y,self.y1)
        self.z1 = min(z,self.z1)
        self.x2 = max(x,self.x2)
        self.y2 = max(y,self.y2)
        self.z2 = max(z,self.z2)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mola.Box.add_point"><code class="name flex">
<span>def <span class="ident">add_point</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<section class="desc"><p>adds a point to the bounding box,
increases the box's size if the point is outside.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_point(self,x,y,z):
    &#34;&#34;&#34;
    adds a point to the bounding box,
    increases the box&#39;s size if the point is outside.
    &#34;&#34;&#34;
    self.x1 = min(x,self.x1)
    self.y1 = min(y,self.y1)
    self.z1 = min(z,self.z1)
    self.x2 = max(x,self.x2)
    self.y2 = max(y,self.y2)
    self.z2 = max(z,self.z2)</code></pre>
</details>
</dd>
<dt id="mola.Box.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the Box's center as a Vertex() object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self):
    &#34;&#34;&#34;
    returns the Box&#39;s center as a Vertex() object
    &#34;&#34;&#34;
    return Vertex((self.x2+self.x1)/2.0,(self.y2+self.y1)/2.0,(self.z2+self.z1)/2.0)</code></pre>
</details>
</dd>
<dt id="mola.Box.dim_x"><code class="name flex">
<span>def <span class="ident">dim_x</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the Box's extent in X direction.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dim_x(self):
    &#34;&#34;&#34;
    Returns the Box&#39;s extent in X direction.
    &#34;&#34;&#34;
    return self.x2 - self.x1</code></pre>
</details>
</dd>
<dt id="mola.Box.dim_y"><code class="name flex">
<span>def <span class="ident">dim_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the Box's extent in Y direction.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dim_y(self):
    &#34;&#34;&#34;
    Returns the Box&#39;s extent in Y direction.
    &#34;&#34;&#34;
    return self.y2 - self.y1</code></pre>
</details>
</dd>
<dt id="mola.Box.dim_z"><code class="name flex">
<span>def <span class="ident">dim_z</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the Box's extent in Z direction.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dim_z(self):
    &#34;&#34;&#34;
    Returns the Box&#39;s extent in Z direction.
    &#34;&#34;&#34;
    return self.z2 - self.z1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mola.Edge"><code class="flex name class">
<span>class <span class="ident">Edge</span></span>
<span>(</span><span>v1, v2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge:
    def __init__(self, v1, v2):
        self.v1 = v1
        self.v2 = v2
        self.face1 = None
        self.face2 = None

    def __str__(self):
        return &#34;from &#34; + str(self.v1)+&#34; to &#34;+ str(self.v2)

    def center(self):
        &#34;&#34;&#34;
        returns the midpoint on an edge as a Vertex() object
        &#34;&#34;&#34;
        return Vertex((self.v2.x+self.v1.x)/2.0,(self.v2.y+self.v1.y)/2.0,(self.v2.z+self.v1.z)/2.0)

    def other_vertex(self,vertex):
        &#34;&#34;&#34;
        if `vertex` is one of the end points of this edge,
        it returns the Vertex at the other end point.
        &#34;&#34;&#34;
        if self.v1 is vertex:
            return self.v2
        if self.v2 is vertex:
            return self.v1
        return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mola.Edge.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the midpoint on an edge as a Vertex() object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self):
    &#34;&#34;&#34;
    returns the midpoint on an edge as a Vertex() object
    &#34;&#34;&#34;
    return Vertex((self.v2.x+self.v1.x)/2.0,(self.v2.y+self.v1.y)/2.0,(self.v2.z+self.v1.z)/2.0)</code></pre>
</details>
</dd>
<dt id="mola.Edge.other_vertex"><code class="name flex">
<span>def <span class="ident">other_vertex</span></span>(<span>self, vertex)</span>
</code></dt>
<dd>
<section class="desc"><p>if <code>vertex</code> is one of the end points of this edge,
it returns the Vertex at the other end point.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def other_vertex(self,vertex):
    &#34;&#34;&#34;
    if `vertex` is one of the end points of this edge,
    it returns the Vertex at the other end point.
    &#34;&#34;&#34;
    if self.v1 is vertex:
        return self.v2
    if self.v2 is vertex:
        return self.v1
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mola.Face"><code class="flex name class">
<span>class <span class="ident">Face</span></span>
<span>(</span><span>vertices=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A <a title="mola.Face" href="#mola.Face"><code>Face</code></a> is the surface between a set of vertices.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>vertices</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of <a title="mola.Vertex" href="#mola.Vertex"><code>Vertex</code></a> objects defining the <a title="mola.Face" href="#mola.Face"><code>Face</code></a>.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code> (<code>r</code>, <code>g</code>, <code>b</code>, <code>a</code>)</dt>
<dd>The color of the face (0..1).</dd>
<dt><strong><code>group</code></strong> :&ensp;<code>integer</code></dt>
<dd>The group index the <a title="mola.Face" href="#mola.Face"><code>Face</code></a> belongs to.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Face:
    &#34;&#34;&#34;A `Face` is the surface between a set of vertices.

    Attributes
    ----------
    vertices : list
        A list of `Vertex` objects defining the `Face`.
    color : tuple (r, g, b, a)
        The color of the face (0..1).
    group : integer
        The group index the `Face` belongs to.
    &#34;&#34;&#34;

    def __init__(self, vertices=None):
        if (vertices == None):
            self.vertices = []
        else:
            self.vertices = vertices
        self.color = (1,1,1,1)
        self.group = 0

    def area(self):
        &#34;&#34;&#34;
        Returns the area of the face.
        &#34;&#34;&#34;
        if(len(self.vertices) == 3):
            return utils_vertex.triangle_area(self.vertices[0], self.vertices[1], self.vertices[2])
        else:
            return utils_vertex.triangle_area(self.vertices[0], self.vertices[1], self.vertices[2]) + utils_vertex.triangle_area(self.vertices[2], self.vertices[3], self.vertices[0])

    def perimeter(self):
        &#34;&#34;&#34;
        Returns the perimeter of the face as the sum of all the edges&#39; lengths.
        &#34;&#34;&#34;
        sum = 0
        for i in range(len(self.vertices)):
            v1 = self.vertices[i]
            v2 = self.vertices[(i + 1) % len(self.vertices)]
            sum += utils_vertex.vertex_distance(v1,v2)
        return sum

    def compactness(self):
        &#34;&#34;&#34;
        Returns the compactness of the face as the ratio between area and perimeter.
        &#34;&#34;&#34;
        return self.area() / self.perimeter()

    def angle_horizontal(self):
        &#34;&#34;&#34;
        Returns the azimuth, the orientation of the face around the z-axis in the XY-plane
        &#34;&#34;&#34;
        n = self.normal()
        return math.atan2(n.y, n.x)

    def angle_vertical(self):
        &#34;&#34;&#34;
        Returns the altitude, 0 if the face is vertical, -Pi/2 if it faces downwards, +Pi/2 if it faces upwards.
        &#34;&#34;&#34;
        n = self.normal()
        #nXY = Vertex(n.x, n.y, 0.0)
        #return vecUtils.angle(n, nXY)
        # alternative, probably less computationally intense:
        return math.asin(n.z)

    def curvature(self):
        &#34;&#34;&#34;
        Returns the local curvature of a mesh face, by measuring the angle to the neighbour faces.
        &#34;&#34;&#34;
        facenormal = self.normal()
        sumD = 0
        vPrev = self.vertices[-1]
        num_faces = 1
        for v in self.vertices:
            edge = v.edge_adjacent_to_vertex(vPrev)
            if edge != None:
                nbFace = edge.face1
                if edge.face1 == self:
                    nbFace = edge.face2
                if nbFace != None:
                    num_faces += 1
                    nbNormal = utils_face.face_normal(nbFace)
                    sumD += utils_vertex.vertex_distance(nbNormal,facenormal)
            vPrev = v
        return sumD / num_faces

    def center(self):
        &#34;&#34;&#34;
        Returns the center point (type Vertex) of the face.
        Note: not the center of gravity, just the average of its vertices.
        &#34;&#34;&#34;
        return utils_vertex.vertices_list_center(self.vertices)

    def normal(self):
        &#34;&#34;&#34;
        Returns the normal of the face, a vector of length 1 perpendicular to the plane of the triangle.
        &#34;&#34;&#34;
        return utils_vertex.triangle_normal(self.vertices[0], self.vertices[1], self.vertices[2])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mola.Face.angle_horizontal"><code class="name flex">
<span>def <span class="ident">angle_horizontal</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the azimuth, the orientation of the face around the z-axis in the XY-plane</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle_horizontal(self):
    &#34;&#34;&#34;
    Returns the azimuth, the orientation of the face around the z-axis in the XY-plane
    &#34;&#34;&#34;
    n = self.normal()
    return math.atan2(n.y, n.x)</code></pre>
</details>
</dd>
<dt id="mola.Face.angle_vertical"><code class="name flex">
<span>def <span class="ident">angle_vertical</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the altitude, 0 if the face is vertical, -Pi/2 if it faces downwards, +Pi/2 if it faces upwards.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle_vertical(self):
    &#34;&#34;&#34;
    Returns the altitude, 0 if the face is vertical, -Pi/2 if it faces downwards, +Pi/2 if it faces upwards.
    &#34;&#34;&#34;
    n = self.normal()
    #nXY = Vertex(n.x, n.y, 0.0)
    #return vecUtils.angle(n, nXY)
    # alternative, probably less computationally intense:
    return math.asin(n.z)</code></pre>
</details>
</dd>
<dt id="mola.Face.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the area of the face.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;
    Returns the area of the face.
    &#34;&#34;&#34;
    if(len(self.vertices) == 3):
        return utils_vertex.triangle_area(self.vertices[0], self.vertices[1], self.vertices[2])
    else:
        return utils_vertex.triangle_area(self.vertices[0], self.vertices[1], self.vertices[2]) + utils_vertex.triangle_area(self.vertices[2], self.vertices[3], self.vertices[0])</code></pre>
</details>
</dd>
<dt id="mola.Face.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the center point (type Vertex) of the face.
Note: not the center of gravity, just the average of its vertices.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self):
    &#34;&#34;&#34;
    Returns the center point (type Vertex) of the face.
    Note: not the center of gravity, just the average of its vertices.
    &#34;&#34;&#34;
    return utils_vertex.vertices_list_center(self.vertices)</code></pre>
</details>
</dd>
<dt id="mola.Face.compactness"><code class="name flex">
<span>def <span class="ident">compactness</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the compactness of the face as the ratio between area and perimeter.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compactness(self):
    &#34;&#34;&#34;
    Returns the compactness of the face as the ratio between area and perimeter.
    &#34;&#34;&#34;
    return self.area() / self.perimeter()</code></pre>
</details>
</dd>
<dt id="mola.Face.curvature"><code class="name flex">
<span>def <span class="ident">curvature</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the local curvature of a mesh face, by measuring the angle to the neighbour faces.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curvature(self):
    &#34;&#34;&#34;
    Returns the local curvature of a mesh face, by measuring the angle to the neighbour faces.
    &#34;&#34;&#34;
    facenormal = self.normal()
    sumD = 0
    vPrev = self.vertices[-1]
    num_faces = 1
    for v in self.vertices:
        edge = v.edge_adjacent_to_vertex(vPrev)
        if edge != None:
            nbFace = edge.face1
            if edge.face1 == self:
                nbFace = edge.face2
            if nbFace != None:
                num_faces += 1
                nbNormal = utils_face.face_normal(nbFace)
                sumD += utils_vertex.vertex_distance(nbNormal,facenormal)
        vPrev = v
    return sumD / num_faces</code></pre>
</details>
</dd>
<dt id="mola.Face.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the normal of the face, a vector of length 1 perpendicular to the plane of the triangle.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal(self):
    &#34;&#34;&#34;
    Returns the normal of the face, a vector of length 1 perpendicular to the plane of the triangle.
    &#34;&#34;&#34;
    return utils_vertex.triangle_normal(self.vertices[0], self.vertices[1], self.vertices[2])</code></pre>
</details>
</dd>
<dt id="mola.Face.perimeter"><code class="name flex">
<span>def <span class="ident">perimeter</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the perimeter of the face as the sum of all the edges' lengths.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perimeter(self):
    &#34;&#34;&#34;
    Returns the perimeter of the face as the sum of all the edges&#39; lengths.
    &#34;&#34;&#34;
    sum = 0
    for i in range(len(self.vertices)):
        v1 = self.vertices[i]
        v2 = self.vertices[(i + 1) % len(self.vertices)]
        sum += utils_vertex.vertex_distance(v1,v2)
    return sum</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mola.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>neighbours, gm=None)</span>
</code></dt>
<dd>
<section class="desc"><p>basic graph class. edge-weighted graphs should implement different weightFunction</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    &#39;&#39;&#39; basic graph class. edge-weighted graphs should implement different weightFunction&#39;&#39;&#39;
    def __init__(self, neighbours, gm=None):
        self.neighbours = neighbours
        self.weight_function = lambda a, b : 1

    def get_neighbours(self, u):
        return self.neighbours[u]

    def size(self):
        return len(self.neighbours)

    def weight(self, index1, index2):
        return self.weight_function(index1, index2)

    @classmethod
    def from_grid_2d(cls, nx, ny, nbs8=False, continuous=False):
        gm = GridManager(nx,ny)
        neighbours = [0] * gm.length
        for i in range(gm.length):
            neighbours[i] = gm.get_neighbors_2d(i, nbs8, continuous)
        return cls(neighbours)

    @classmethod
    def from_hex_grid_2d(cls, nx, ny,continuous=False):
        gm = GridManager(nx, ny)
        neighbours = [0] * gm.length
        for i in range(gm.length):
            neighbours[i] = gm.get_neighbors_hex_2d(i, continuous)
        return cls(neighbours)

    @classmethod
    def from_grid_3d(cls, nx, ny, nz, mode=3, continuous=False):
        gm = GridManager(nx, ny, nz)
        neighbours = [0] * gm.length
        for i in range(gm.length):
            neighbours[i] = gm.get_neighbors_3d(i, mode, continuous)
        return cls(neighbours)

    @classmethod
    def from_mesh_faces(cls, mesh):
        faceIds = {}
        neighbours = [0] * len(mesh.faces)
        for index, face in enumerate(mesh.faces):
            faceIds[face] = index
        for index, face in enumerate(mesh.faces):
            nbs = []
            v0 = face.vertices[-1]
            for v1 in face.vertices:
                nbFace = mesh.getFaceAdjacentToVertices(v1, v0)
                nbs.append(faceIds[nbFace])
                v0 = v1
            neighbours[index] = nbs
        return cls(neighbours)

    def from_mesh_edges(self,mesh):
        pass

    def from_mesh_vertices(self,mesh):
        pass</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="mola.Graph.from_grid_2d"><code class="name flex">
<span>def <span class="ident">from_grid_2d</span></span>(<span>nx, ny, nbs8=False, continuous=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_grid_2d(cls, nx, ny, nbs8=False, continuous=False):
    gm = GridManager(nx,ny)
    neighbours = [0] * gm.length
    for i in range(gm.length):
        neighbours[i] = gm.get_neighbors_2d(i, nbs8, continuous)
    return cls(neighbours)</code></pre>
</details>
</dd>
<dt id="mola.Graph.from_grid_3d"><code class="name flex">
<span>def <span class="ident">from_grid_3d</span></span>(<span>nx, ny, nz, mode=3, continuous=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_grid_3d(cls, nx, ny, nz, mode=3, continuous=False):
    gm = GridManager(nx, ny, nz)
    neighbours = [0] * gm.length
    for i in range(gm.length):
        neighbours[i] = gm.get_neighbors_3d(i, mode, continuous)
    return cls(neighbours)</code></pre>
</details>
</dd>
<dt id="mola.Graph.from_hex_grid_2d"><code class="name flex">
<span>def <span class="ident">from_hex_grid_2d</span></span>(<span>nx, ny, continuous=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_hex_grid_2d(cls, nx, ny,continuous=False):
    gm = GridManager(nx, ny)
    neighbours = [0] * gm.length
    for i in range(gm.length):
        neighbours[i] = gm.get_neighbors_hex_2d(i, continuous)
    return cls(neighbours)</code></pre>
</details>
</dd>
<dt id="mola.Graph.from_mesh_faces"><code class="name flex">
<span>def <span class="ident">from_mesh_faces</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_mesh_faces(cls, mesh):
    faceIds = {}
    neighbours = [0] * len(mesh.faces)
    for index, face in enumerate(mesh.faces):
        faceIds[face] = index
    for index, face in enumerate(mesh.faces):
        nbs = []
        v0 = face.vertices[-1]
        for v1 in face.vertices:
            nbFace = mesh.getFaceAdjacentToVertices(v1, v0)
            nbs.append(faceIds[nbFace])
            v0 = v1
        neighbours[index] = nbs
    return cls(neighbours)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mola.Graph.from_mesh_edges"><code class="name flex">
<span>def <span class="ident">from_mesh_edges</span></span>(<span>self, mesh)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_mesh_edges(self,mesh):
    pass</code></pre>
</details>
</dd>
<dt id="mola.Graph.from_mesh_vertices"><code class="name flex">
<span>def <span class="ident">from_mesh_vertices</span></span>(<span>self, mesh)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_mesh_vertices(self,mesh):
    pass</code></pre>
</details>
</dd>
<dt id="mola.Graph.get_neighbours"><code class="name flex">
<span>def <span class="ident">get_neighbours</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbours(self, u):
    return self.neighbours[u]</code></pre>
</details>
</dd>
<dt id="mola.Graph.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self):
    return len(self.neighbours)</code></pre>
</details>
</dd>
<dt id="mola.Graph.weight"><code class="name flex">
<span>def <span class="ident">weight</span></span>(<span>self, index1, index2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight(self, index1, index2):
    return self.weight_function(index1, index2)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mola.GraphAnalyser"><code class="flex name class">
<span>class <span class="ident">GraphAnalyser</span></span>
<span>(</span><span>graph)</span>
</code></dt>
<dd>
<section class="desc"><p>works with graphs which provide 3 methods: size(), getNeighbours(), and weight()
this class stores all distances in order to allow a fast calculation of path to predefined starting points
usage: construct a Graphanalyser
1. compute distance to a list of starting points
2. getShortest Path from end point to those starting point</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphAnalyser:
    &#34;&#34;&#34;
    works with graphs which provide 3 methods: size(), getNeighbours(), and weight()
    this class stores all distances in order to allow a fast calculation of path to predefined starting points
    usage: construct a Graphanalyser
    1. compute distance to a list of starting points
    2. getShortest Path from end point to those starting point
    &#34;&#34;&#34;
    def __init__(self,graph):
        self.n = graph.size()
        self.graph = graph
        self.dist = [1000000] * self.n
        self.pred = [-1] * self.n

    def compute_distance_to_nodes(self,startIndexes):
        pq = PriorityQueue()
        for i in startIndexes:
            self.dist[i] = 0
            pq.put((0,i))
        while not pq.empty():
            u = pq.get()[1]
            nbs = self.graph.get_neighbours(u)
            for v in nbs:
                d = self.dist[u] + self.graph.weight(u,v)
                if d &lt; self.dist[v]:
                    self.dist[v] = d
                    self.pred[v] = u
                    pq.put((d, v))

    def shortest_path(self,v):
        p = []
        while v != -1:
            p.append(v)
            v = self.pred[v]
        return p

    def compute_traffic_and_centrality(self,nodes):
        n = self.n
        self.traffic = [0] * n
        self.centrality = [0] * n
        for i in range(len(nodes) - 1):
            startI = nodes[i]
            self.dist = [100000] * n
            self.pred = [-1] * n
            self.compute_distance_to_nodes([startI])
            for j in range(i,len(nodes)):
                endI = nodes[j]
                if endI != startI:
                    self.centrality[startI] += self.dist[endI]
                    self.centrality[endI] += self.dist[endI]
                    path = self.shortest_path(endI)
                    for ii in path:
                        cI = path[ii]
                        self.traffic[cI] += 1</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mola.GraphAnalyser.compute_distance_to_nodes"><code class="name flex">
<span>def <span class="ident">compute_distance_to_nodes</span></span>(<span>self, startIndexes)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_distance_to_nodes(self,startIndexes):
    pq = PriorityQueue()
    for i in startIndexes:
        self.dist[i] = 0
        pq.put((0,i))
    while not pq.empty():
        u = pq.get()[1]
        nbs = self.graph.get_neighbours(u)
        for v in nbs:
            d = self.dist[u] + self.graph.weight(u,v)
            if d &lt; self.dist[v]:
                self.dist[v] = d
                self.pred[v] = u
                pq.put((d, v))</code></pre>
</details>
</dd>
<dt id="mola.GraphAnalyser.compute_traffic_and_centrality"><code class="name flex">
<span>def <span class="ident">compute_traffic_and_centrality</span></span>(<span>self, nodes)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_traffic_and_centrality(self,nodes):
    n = self.n
    self.traffic = [0] * n
    self.centrality = [0] * n
    for i in range(len(nodes) - 1):
        startI = nodes[i]
        self.dist = [100000] * n
        self.pred = [-1] * n
        self.compute_distance_to_nodes([startI])
        for j in range(i,len(nodes)):
            endI = nodes[j]
            if endI != startI:
                self.centrality[startI] += self.dist[endI]
                self.centrality[endI] += self.dist[endI]
                path = self.shortest_path(endI)
                for ii in path:
                    cI = path[ii]
                    self.traffic[cI] += 1</code></pre>
</details>
</dd>
<dt id="mola.GraphAnalyser.shortest_path"><code class="name flex">
<span>def <span class="ident">shortest_path</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shortest_path(self,v):
    p = []
    while v != -1:
        p.append(v)
        v = self.pred[v]
    return p</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mola.Grid"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
<span>(</span><span>nx, ny, nz=1, values=None, scale_to_canvas=False)</span>
</code></dt>
<dd>
<section class="desc"><p>A <a title="mola.GridManager" href="#mola.GridManager"><code>GridManager</code></a> is taking care of getting and setting values and
retrieving neighbors in an orthogonal grid of either 2 or 3 dimension.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>nx</code></strong>, <strong><code>ny</code></strong>, <strong><code>nz</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of elements in x,y and z direction.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grid(GridManager):
    def __init__(self, nx, ny, nz=1, values=None, scale_to_canvas=False):
        super().__init__(nx, ny, nz)
        # self.nx = nx
        # self.ny = ny
        # self.nz = nz
        # self.nyz = ny * nz
        self.scale_to_canvas = scale_to_canvas;
        if values is None:
            self.values = [0] * nx * ny * nz
        else:
            self.values = values

    def set_value_at_xyz(self, value, x, y, z=0):
        self.values[self.get_index(x, y, z)] = value

    def get_value_at_xyz(self, x, y, z=0):
        return self.values[self.get_index(x, y, z)]

    def set_value_at_index(self, value, index):
        self.values[index] = value

    def get_value_at_index(self, index):
        return self.values[index]

    def shortest_path(self, startindex, endindex, obstaclevalue):
        # TODO
        return []

    def quad_mesh(self, functionIn, functionOut):
        faces = []
        for x in range(self.nx):
            for y in range(self.ny):
                for z in range(self.nz):
                    index=self.get_index(x,y,z)
                    if functionIn(self.values[index]):
                        # (x,y) (x1,y) (x1,y1) (x,y1)
                        if x == self.nx - 1 or functionOut(self.get_value_at_xyz(x + 1, y, z)):
                            v1 = Vertex(x + 1, y, z)
                            v2 = Vertex(x + 1, y + 1, z)
                            v3 = Vertex(x + 1, y + 1, z + 1)
                            v4 = Vertex(x + 1, y, z + 1)
                            faces.append(Face([v1, v2, v3, v4]))
                        if x == 0 or functionOut(self.get_value_at_xyz(x-1,y,z)):
                            v1 = Vertex(x, y + 1, z)
                            v2 = Vertex(x, y, z)
                            v3 = Vertex(x, y, z + 1)
                            v4 = Vertex(x, y + 1, z + 1)
                            faces.append(Face([v1, v2, v3, v4]))
                        if y == self.ny - 1 or functionOut(self.get_value_at_xyz(x, y + 1, z)):
                            v1 = Vertex(x + 1, y + 1, z)
                            v2 = Vertex(x, y + 1, z)
                            v3 = Vertex(x, y + 1, z + 1)
                            v4 = Vertex(x + 1, y + 1, z + 1)
                            faces.append(Face([v1, v2, v3, v4]))
                        if y == 0 or functionOut(self.get_value_at_xyz(x, y - 1, z)):
                            v1 = Vertex(x, y, z)
                            v2 = Vertex(x + 1, y, z)
                            v3 = Vertex(x + 1, y, z + 1)
                            v4 = Vertex(x, y, z + 1)
                            faces.append(Face([v1, v2, v3, v4]))
                        if z==self.nz-1 or functionOut(self.get_value_at_xyz(x, y, z + 1)):
                            v1 = Vertex(x, y, z + 1)
                            v2 = Vertex(x + 1, y, z + 1)
                            v3 = Vertex(x + 1, y + 1, z + 1)
                            v4 = Vertex(x, y + 1, z + 1)
                            faces.append(Face([v1, v2, v3, v4]))
                        if z == 0 or functionOut(self.get_value_at_xyz(x, y, z - 1)):
                            v1 = Vertex(x, y + 1, z)
                            v2 = Vertex(x + 1, y + 1, z)
                            v3 = Vertex(x + 1, y, z)
                            v4 = Vertex(x, y, z)
                            faces.append(Face([v1, v2, v3, v4]))
        mesh = Mesh()
        mesh.faces = faces
        mesh.update_topology()
        if (self.scale_to_canvas):
            mesh.translate(-self.nx/2.0,-self.ny/2.0,-self.nz/2.0)
            sc = 20.0/max(self.nx,self.ny)
            mesh.scale(sc,sc,sc)
        return mesh</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mola.core_grid.GridManager" href="core_grid.html#mola.core_grid.GridManager">GridManager</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mola.core_grid.HexGrid" href="core_grid.html#mola.core_grid.HexGrid">HexGrid</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mola.Grid.get_value_at_index"><code class="name flex">
<span>def <span class="ident">get_value_at_index</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_at_index(self, index):
    return self.values[index]</code></pre>
</details>
</dd>
<dt id="mola.Grid.get_value_at_xyz"><code class="name flex">
<span>def <span class="ident">get_value_at_xyz</span></span>(<span>self, x, y, z=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_at_xyz(self, x, y, z=0):
    return self.values[self.get_index(x, y, z)]</code></pre>
</details>
</dd>
<dt id="mola.Grid.quad_mesh"><code class="name flex">
<span>def <span class="ident">quad_mesh</span></span>(<span>self, functionIn, functionOut)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quad_mesh(self, functionIn, functionOut):
    faces = []
    for x in range(self.nx):
        for y in range(self.ny):
            for z in range(self.nz):
                index=self.get_index(x,y,z)
                if functionIn(self.values[index]):
                    # (x,y) (x1,y) (x1,y1) (x,y1)
                    if x == self.nx - 1 or functionOut(self.get_value_at_xyz(x + 1, y, z)):
                        v1 = Vertex(x + 1, y, z)
                        v2 = Vertex(x + 1, y + 1, z)
                        v3 = Vertex(x + 1, y + 1, z + 1)
                        v4 = Vertex(x + 1, y, z + 1)
                        faces.append(Face([v1, v2, v3, v4]))
                    if x == 0 or functionOut(self.get_value_at_xyz(x-1,y,z)):
                        v1 = Vertex(x, y + 1, z)
                        v2 = Vertex(x, y, z)
                        v3 = Vertex(x, y, z + 1)
                        v4 = Vertex(x, y + 1, z + 1)
                        faces.append(Face([v1, v2, v3, v4]))
                    if y == self.ny - 1 or functionOut(self.get_value_at_xyz(x, y + 1, z)):
                        v1 = Vertex(x + 1, y + 1, z)
                        v2 = Vertex(x, y + 1, z)
                        v3 = Vertex(x, y + 1, z + 1)
                        v4 = Vertex(x + 1, y + 1, z + 1)
                        faces.append(Face([v1, v2, v3, v4]))
                    if y == 0 or functionOut(self.get_value_at_xyz(x, y - 1, z)):
                        v1 = Vertex(x, y, z)
                        v2 = Vertex(x + 1, y, z)
                        v3 = Vertex(x + 1, y, z + 1)
                        v4 = Vertex(x, y, z + 1)
                        faces.append(Face([v1, v2, v3, v4]))
                    if z==self.nz-1 or functionOut(self.get_value_at_xyz(x, y, z + 1)):
                        v1 = Vertex(x, y, z + 1)
                        v2 = Vertex(x + 1, y, z + 1)
                        v3 = Vertex(x + 1, y + 1, z + 1)
                        v4 = Vertex(x, y + 1, z + 1)
                        faces.append(Face([v1, v2, v3, v4]))
                    if z == 0 or functionOut(self.get_value_at_xyz(x, y, z - 1)):
                        v1 = Vertex(x, y + 1, z)
                        v2 = Vertex(x + 1, y + 1, z)
                        v3 = Vertex(x + 1, y, z)
                        v4 = Vertex(x, y, z)
                        faces.append(Face([v1, v2, v3, v4]))
    mesh = Mesh()
    mesh.faces = faces
    mesh.update_topology()
    if (self.scale_to_canvas):
        mesh.translate(-self.nx/2.0,-self.ny/2.0,-self.nz/2.0)
        sc = 20.0/max(self.nx,self.ny)
        mesh.scale(sc,sc,sc)
    return mesh</code></pre>
</details>
</dd>
<dt id="mola.Grid.set_value_at_index"><code class="name flex">
<span>def <span class="ident">set_value_at_index</span></span>(<span>self, value, index)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value_at_index(self, value, index):
    self.values[index] = value</code></pre>
</details>
</dd>
<dt id="mola.Grid.set_value_at_xyz"><code class="name flex">
<span>def <span class="ident">set_value_at_xyz</span></span>(<span>self, value, x, y, z=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value_at_xyz(self, value, x, y, z=0):
    self.values[self.get_index(x, y, z)] = value</code></pre>
</details>
</dd>
<dt id="mola.Grid.shortest_path"><code class="name flex">
<span>def <span class="ident">shortest_path</span></span>(<span>self, startindex, endindex, obstaclevalue)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shortest_path(self, startindex, endindex, obstaclevalue):
    # TODO
    return []</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mola.core_grid.GridManager" href="core_grid.html#mola.core_grid.GridManager">GridManager</a></b></code>:
<ul class="hlist">
<li><code><a title="mola.core_grid.GridManager.get_index" href="core_grid.html#mola.core_grid.GridManager.get_index">get_index</a></code></li>
<li><code><a title="mola.core_grid.GridManager.get_neighbors_2d" href="core_grid.html#mola.core_grid.GridManager.get_neighbors_2d">get_neighbors_2d</a></code></li>
<li><code><a title="mola.core_grid.GridManager.get_neighbors_hex_2d" href="core_grid.html#mola.core_grid.GridManager.get_neighbors_hex_2d">get_neighbors_hex_2d</a></code></li>
<li><code><a title="mola.core_grid.GridManager.get_x" href="core_grid.html#mola.core_grid.GridManager.get_x">get_x</a></code></li>
<li><code><a title="mola.core_grid.GridManager.get_y" href="core_grid.html#mola.core_grid.GridManager.get_y">get_y</a></code></li>
<li><code><a title="mola.core_grid.GridManager.get_z" href="core_grid.html#mola.core_grid.GridManager.get_z">get_z</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mola.GridManager"><code class="flex name class">
<span>class <span class="ident">GridManager</span></span>
<span>(</span><span>nx, ny, nz=1)</span>
</code></dt>
<dd>
<section class="desc"><p>A <a title="mola.GridManager" href="#mola.GridManager"><code>GridManager</code></a> is taking care of getting and setting values and
retrieving neighbors in an orthogonal grid of either 2 or 3 dimension.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>nx</code></strong>, <strong><code>ny</code></strong>, <strong><code>nz</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of elements in x,y and z direction.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GridManager:
    &#34;&#34;&#34;
    A `GridManager` is taking care of getting and setting values and
    retrieving neighbors in an orthogonal grid of either 2 or 3 dimension.

    Attributes
    ----------
    nx, ny, nz : int
        The number of elements in x,y and z direction.
    &#34;&#34;&#34;
    def __init__(self, nx, ny, nz=1):
        self.nx = nx
        self.ny = ny
        self.nz = nz
        self.length = nx * ny * nz
        self.nyz = ny * nz

    def get_index(self, x, y, z=0):
        &#34;&#34;&#34;
        returns the value at position x,y,z
        &#34;&#34;&#34;
        return x * self.nyz + y * self.nz + z

    def get_x(self,index):
        &#34;&#34;&#34;
        returns the X coordinate of a specific index
        &#34;&#34;&#34;
        return index // self.nyz

    def get_y(self,index):
        &#34;&#34;&#34;
        returns the Y coordinate of a specific index
        &#34;&#34;&#34;
        return (index // self.nz) % self.ny

    def get_z(self,index):
        &#34;&#34;&#34;
        returns the Z coordinate of a specific index
        &#34;&#34;&#34;
        return index % self.nz

    def get_neighbors_hex_2d(self,index,continuous=False):
        &#34;&#34;&#34;
        returns the 6 neighbor indices of a cell in a hexagonal grid
        set `continuous` to `True` to get torus topology (left edge stitched to right and top to bottom)
        &#34;&#34;&#34;
        nbs = []
        x = self.get_x(index)
        y = self.get_y(index)
        if not continuous:
            if x &lt; self.nx - 1:
                nbs.append(self.get_index(x + 1, y))
            if x &gt; 0:
                nbs.append(self.get_index(x - 1, y))
            if y &gt; 0:
                nbs.append(self.get_index(x, y - 1))
            if y &lt; self.ny - 1:
                nbs.append(self.get_index(x, y + 1))
            if y % 2 == 0:
                if x &lt; self.nx - 1 and y &lt; self.ny - 1:
                    nbs.append(self.get_index(x + 1, y + 1))
                if x &lt; self.nx - 1 and y &gt; 0:
                    nbs.append(self.get_index(x + 1, y - 1))
            else:
                if x &gt; 0 and y &lt; self.ny - 1:
                    nbs.append(self.get_index(x - 1, y + 1))
                if x &gt; 0 and y &gt; 0:
                    nbs.append(self.get_index(x - 1, y - 1))
        else:
            xNext = x + 1 if x &lt; self.nx - 1 else 0
            xPrev = x - 1 if x &gt; 0 else self.nx - 1
            yNext = y + 1 if y &lt; self.ny - 1 else 0
            yPrev = y - 1 if y &gt; 0 else self.ny - 1
            nbs.append(self.get_index(xNext, y))
            nbs.append(self.get_index(xPrev, y))
            nbs.append(self.get_index(x, yPrev))
            nbs.append(self.get_index(x, yNext))
            if y % 2 == 0:
                nbs.append(self.get_index(xNext, yNext))
                nbs.append(self.get_index(xNext, yPrev))
            else:
                nbs.append(self.get_index(xPrev, yNext))
                nbs.append(self.get_index(xPrev, yPrev))
        return nbs

    def get_neighbors_2d(self,index,nbs8=False,continuous=False):
        &#34;&#34;&#34;
        returns the neighbor indices of a cell in an orthogonal grid
        set `nbs8` to `True` to get 8 neighbors, default is 4
        set `continuous` to `True` to get torus topology (left edge stitched to right and top to bottom)
        &#34;&#34;&#34;
        nbs = []
        x = self.get_x(index)
        y = self.get_y(index)
        if not continuous:
            if x &lt; self.nx - 1:
                nbs.append(self.get_index(x + 1, y))
            if nbs8:
                if x &lt; self.nx - 1 and y &lt; self.ny - 1:
                    nbs.append(self.get_index(x + 1, y + 1))
            if y &lt; self.ny - 1:
                nbs.append(self.get_index(x, y + 1))
            if nbs8:
                if x &gt; 0 and y &lt; self.ny - 1:
                    nbs.append(self.get_index(x - 1, y + 1))
            if x &gt; 0:
                nbs.append(self.get_index(x - 1, y))
            if nbs8:
                if x &gt; 0 and y &gt; 0:
                    nbs.append(self.get_index(x - 1, y - 1))
            if y &gt; 0:
                nbs.append(self.get_index(x, y - 1))
            if nbs8:
                if x &lt; self.nx - 1 and y &gt; 0:
                    nbs.append(self.get_index(x + 1, y - 1))
        else:
            xPrev = x - 1 if x &gt; 0 else self.nx - 1
            xNext = x + 1 if x &lt; self.nx - 1 else 0
            yPrev = y - 1 if y &gt; 0 else self.ny - 1
            yNext = y + 1 if y &lt; self.ny - 1 else 0
            nbs.append(self.get_index(xNext, y))
            if nbs8:
                nbs.append(self.get_index(xNext, yNext))
            nbs.append(self.get_index(x, yNext))
            if nbs8:
                nbs.append(self.get_index(xPrev, yNext))
            nbs.append(self.get_index(xPrev, y))
            if nbs8:
                nbs.append(self.get_index(xPrev, yPrev))
            nbs.append(self.get_index(x, yPrev))
            if nbs8:
                nbs.append(self.get_index(xNext, yPrev))
        return nbs

    def get_neighbors_3d(self, index, mode=3, continuous=False):
        nbs = []
        x = self.get_x(index)
        y = self.get_y(index)
        z = self.get_z(index)

        # mode: neighbourhood type
        # 1 :  6 nbs, shared face
        # 2 : 18 nbs, shared face or edge
        # 3 : 26 nbs, shared face, edge or vertex
        if not mode:
            mode==3
        if mode&lt;1:
            mode==1
        if mode&gt;3:
            mode==3

        # precalculate distances
        # dists = [1, math.sqrt(2), math.sqrt(3)]

        # create a list of directions with x,y and z offsets
        directions = []
        for i in range(-1,2):
            for j in range(-1,2):
                for k in range(-1,2):
                    l = [i,j,k]
                    s = sum([abs(v) for v in l])
                    # check for neighbourhood type
                    if s &gt; 0 and s &lt;= mode:
                        directions.append(l)

        for d in directions:
            ex = x + d[0]
            ey = y + d[1]
            ez = z + d[2]
            if continuous:
                ex = ex % self.nx
                ey = ey % self.ny
                ez = ez % self.nz
            if 0 &lt;= ex &lt; self.nx and 0 &lt;= ey &lt; self.ny and 0 &lt;= ez &lt; self.nz:
                nbs.append(self.get_index(ex,ey,ez))

        return nbs</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mola.core_grid.Grid" href="core_grid.html#mola.core_grid.Grid">Grid</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mola.GridManager.get_index"><code class="name flex">
<span>def <span class="ident">get_index</span></span>(<span>self, x, y, z=0)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the value at position x,y,z</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index(self, x, y, z=0):
    &#34;&#34;&#34;
    returns the value at position x,y,z
    &#34;&#34;&#34;
    return x * self.nyz + y * self.nz + z</code></pre>
</details>
</dd>
<dt id="mola.GridManager.get_neighbors_2d"><code class="name flex">
<span>def <span class="ident">get_neighbors_2d</span></span>(<span>self, index, nbs8=False, continuous=False)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the neighbor indices of a cell in an orthogonal grid
set <code>nbs8</code> to <code>True</code> to get 8 neighbors, default is 4
set <code>continuous</code> to <code>True</code> to get torus topology (left edge stitched to right and top to bottom)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbors_2d(self,index,nbs8=False,continuous=False):
    &#34;&#34;&#34;
    returns the neighbor indices of a cell in an orthogonal grid
    set `nbs8` to `True` to get 8 neighbors, default is 4
    set `continuous` to `True` to get torus topology (left edge stitched to right and top to bottom)
    &#34;&#34;&#34;
    nbs = []
    x = self.get_x(index)
    y = self.get_y(index)
    if not continuous:
        if x &lt; self.nx - 1:
            nbs.append(self.get_index(x + 1, y))
        if nbs8:
            if x &lt; self.nx - 1 and y &lt; self.ny - 1:
                nbs.append(self.get_index(x + 1, y + 1))
        if y &lt; self.ny - 1:
            nbs.append(self.get_index(x, y + 1))
        if nbs8:
            if x &gt; 0 and y &lt; self.ny - 1:
                nbs.append(self.get_index(x - 1, y + 1))
        if x &gt; 0:
            nbs.append(self.get_index(x - 1, y))
        if nbs8:
            if x &gt; 0 and y &gt; 0:
                nbs.append(self.get_index(x - 1, y - 1))
        if y &gt; 0:
            nbs.append(self.get_index(x, y - 1))
        if nbs8:
            if x &lt; self.nx - 1 and y &gt; 0:
                nbs.append(self.get_index(x + 1, y - 1))
    else:
        xPrev = x - 1 if x &gt; 0 else self.nx - 1
        xNext = x + 1 if x &lt; self.nx - 1 else 0
        yPrev = y - 1 if y &gt; 0 else self.ny - 1
        yNext = y + 1 if y &lt; self.ny - 1 else 0
        nbs.append(self.get_index(xNext, y))
        if nbs8:
            nbs.append(self.get_index(xNext, yNext))
        nbs.append(self.get_index(x, yNext))
        if nbs8:
            nbs.append(self.get_index(xPrev, yNext))
        nbs.append(self.get_index(xPrev, y))
        if nbs8:
            nbs.append(self.get_index(xPrev, yPrev))
        nbs.append(self.get_index(x, yPrev))
        if nbs8:
            nbs.append(self.get_index(xNext, yPrev))
    return nbs</code></pre>
</details>
</dd>
<dt id="mola.GridManager.get_neighbors_3d"><code class="name flex">
<span>def <span class="ident">get_neighbors_3d</span></span>(<span>self, index, mode=3, continuous=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbors_3d(self, index, mode=3, continuous=False):
    nbs = []
    x = self.get_x(index)
    y = self.get_y(index)
    z = self.get_z(index)

    # mode: neighbourhood type
    # 1 :  6 nbs, shared face
    # 2 : 18 nbs, shared face or edge
    # 3 : 26 nbs, shared face, edge or vertex
    if not mode:
        mode==3
    if mode&lt;1:
        mode==1
    if mode&gt;3:
        mode==3

    # precalculate distances
    # dists = [1, math.sqrt(2), math.sqrt(3)]

    # create a list of directions with x,y and z offsets
    directions = []
    for i in range(-1,2):
        for j in range(-1,2):
            for k in range(-1,2):
                l = [i,j,k]
                s = sum([abs(v) for v in l])
                # check for neighbourhood type
                if s &gt; 0 and s &lt;= mode:
                    directions.append(l)

    for d in directions:
        ex = x + d[0]
        ey = y + d[1]
        ez = z + d[2]
        if continuous:
            ex = ex % self.nx
            ey = ey % self.ny
            ez = ez % self.nz
        if 0 &lt;= ex &lt; self.nx and 0 &lt;= ey &lt; self.ny and 0 &lt;= ez &lt; self.nz:
            nbs.append(self.get_index(ex,ey,ez))

    return nbs</code></pre>
</details>
</dd>
<dt id="mola.GridManager.get_neighbors_hex_2d"><code class="name flex">
<span>def <span class="ident">get_neighbors_hex_2d</span></span>(<span>self, index, continuous=False)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the 6 neighbor indices of a cell in a hexagonal grid
set <code>continuous</code> to <code>True</code> to get torus topology (left edge stitched to right and top to bottom)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbors_hex_2d(self,index,continuous=False):
    &#34;&#34;&#34;
    returns the 6 neighbor indices of a cell in a hexagonal grid
    set `continuous` to `True` to get torus topology (left edge stitched to right and top to bottom)
    &#34;&#34;&#34;
    nbs = []
    x = self.get_x(index)
    y = self.get_y(index)
    if not continuous:
        if x &lt; self.nx - 1:
            nbs.append(self.get_index(x + 1, y))
        if x &gt; 0:
            nbs.append(self.get_index(x - 1, y))
        if y &gt; 0:
            nbs.append(self.get_index(x, y - 1))
        if y &lt; self.ny - 1:
            nbs.append(self.get_index(x, y + 1))
        if y % 2 == 0:
            if x &lt; self.nx - 1 and y &lt; self.ny - 1:
                nbs.append(self.get_index(x + 1, y + 1))
            if x &lt; self.nx - 1 and y &gt; 0:
                nbs.append(self.get_index(x + 1, y - 1))
        else:
            if x &gt; 0 and y &lt; self.ny - 1:
                nbs.append(self.get_index(x - 1, y + 1))
            if x &gt; 0 and y &gt; 0:
                nbs.append(self.get_index(x - 1, y - 1))
    else:
        xNext = x + 1 if x &lt; self.nx - 1 else 0
        xPrev = x - 1 if x &gt; 0 else self.nx - 1
        yNext = y + 1 if y &lt; self.ny - 1 else 0
        yPrev = y - 1 if y &gt; 0 else self.ny - 1
        nbs.append(self.get_index(xNext, y))
        nbs.append(self.get_index(xPrev, y))
        nbs.append(self.get_index(x, yPrev))
        nbs.append(self.get_index(x, yNext))
        if y % 2 == 0:
            nbs.append(self.get_index(xNext, yNext))
            nbs.append(self.get_index(xNext, yPrev))
        else:
            nbs.append(self.get_index(xPrev, yNext))
            nbs.append(self.get_index(xPrev, yPrev))
    return nbs</code></pre>
</details>
</dd>
<dt id="mola.GridManager.get_x"><code class="name flex">
<span>def <span class="ident">get_x</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the X coordinate of a specific index</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_x(self,index):
    &#34;&#34;&#34;
    returns the X coordinate of a specific index
    &#34;&#34;&#34;
    return index // self.nyz</code></pre>
</details>
</dd>
<dt id="mola.GridManager.get_y"><code class="name flex">
<span>def <span class="ident">get_y</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the Y coordinate of a specific index</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_y(self,index):
    &#34;&#34;&#34;
    returns the Y coordinate of a specific index
    &#34;&#34;&#34;
    return (index // self.nz) % self.ny</code></pre>
</details>
</dd>
<dt id="mola.GridManager.get_z"><code class="name flex">
<span>def <span class="ident">get_z</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the Z coordinate of a specific index</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_z(self,index):
    &#34;&#34;&#34;
    returns the Z coordinate of a specific index
    &#34;&#34;&#34;
    return index % self.nz</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mola.HexGrid"><code class="flex name class">
<span>class <span class="ident">HexGrid</span></span>
<span>(</span><span>nx, ny, nz=1, values=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A <a title="mola.GridManager" href="#mola.GridManager"><code>GridManager</code></a> is taking care of getting and setting values and
retrieving neighbors in an orthogonal grid of either 2 or 3 dimension.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>nx</code></strong>, <strong><code>ny</code></strong>, <strong><code>nz</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of elements in x,y and z direction.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HexGrid(Grid):
    def __init__(self, nx, ny, nz=1, values=None):
        super().__init__(nx, ny, nz, values)
        # self.ny = nx
        # self.ny = ny
        # self.nz = nz
        # self.nyz = ny * nz
        # if values == None:
        #     self.values = [0] * nx * ny * nz
        self.dimy = math.sqrt(3) * 0.5

    def get_position(self, x, y, z=0):
        return [x + (y % 2) * 0.5, y * self.dimy, z]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mola.core_grid.Grid" href="core_grid.html#mola.core_grid.Grid">Grid</a></li>
<li><a title="mola.core_grid.GridManager" href="core_grid.html#mola.core_grid.GridManager">GridManager</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mola.HexGrid.get_position"><code class="name flex">
<span>def <span class="ident">get_position</span></span>(<span>self, x, y, z=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_position(self, x, y, z=0):
    return [x + (y % 2) * 0.5, y * self.dimy, z]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mola.core_grid.Grid" href="core_grid.html#mola.core_grid.Grid">Grid</a></b></code>:
<ul class="hlist">
<li><code><a title="mola.core_grid.Grid.get_index" href="core_grid.html#mola.core_grid.GridManager.get_index">get_index</a></code></li>
<li><code><a title="mola.core_grid.Grid.get_neighbors_2d" href="core_grid.html#mola.core_grid.GridManager.get_neighbors_2d">get_neighbors_2d</a></code></li>
<li><code><a title="mola.core_grid.Grid.get_neighbors_hex_2d" href="core_grid.html#mola.core_grid.GridManager.get_neighbors_hex_2d">get_neighbors_hex_2d</a></code></li>
<li><code><a title="mola.core_grid.Grid.get_x" href="core_grid.html#mola.core_grid.GridManager.get_x">get_x</a></code></li>
<li><code><a title="mola.core_grid.Grid.get_y" href="core_grid.html#mola.core_grid.GridManager.get_y">get_y</a></code></li>
<li><code><a title="mola.core_grid.Grid.get_z" href="core_grid.html#mola.core_grid.GridManager.get_z">get_z</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mola.Mesh"><code class="flex name class">
<span>class <span class="ident">Mesh</span></span>
</code></dt>
<dd>
<section class="desc"><p>A mesh describes a 3D surface made of Vertices connected by Faces.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>vertices</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of <a title="mola.Vertex" href="#mola.Vertex"><code>Vertex</code></a> objects in the mesh.</dd>
<dt><strong><code>faces</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of <a title="mola.Face" href="#mola.Face"><code>Face</code></a> objects in the mesh.</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of edges in the mesh.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mesh:
    &#34;&#34;&#34;A mesh describes a 3D surface made of Vertices connected by Faces.

    Attributes
    ----------
    vertices : list
        The list of `Vertex` objects in the mesh.
    faces : list
        The list of `Face` objects in the mesh.
    edges : list
        The list of edges in the mesh.
    &#34;&#34;&#34;
    def __init__(self):
        self.vertices = []
        self.faces = []
        self.edges = []

    def scale(self, sx, sy, sz):
        &#34;&#34;&#34;
        scales a mesh by adding multiplying
        the position of its vertices by sx, sy and sz.
        &#34;&#34;&#34;
        #vs = Vertex(sx, sy, sz)
        for v in self.vertices:
            v.x *= sx
            v.y *= sy
            v.z *= sz

    def translate(self, tx, ty, tz):
        &#34;&#34;&#34;
        translates a mesh by adding tx,ty and tz
        to the position of the vertices.
        &#34;&#34;&#34;
        vt = Vertex(tx, ty, tz)
        for v in self.vertices:
            v.add(vt)

    def bounding_box(self):
        &#34;&#34;&#34;
        returns the bounding box of this mesh as a Box() object
        &#34;&#34;&#34;
        box = Box()
        for f in self.faces:
            for v in f.vertices:
                box.add_point(v.x,v.y,v.z)
        return box

    def center(self):
        &#34;&#34;&#34;
        Returns the center of the Mesh as a Vertex() object
        Note: not the center of gravity, just the average of its vertices.
        &#34;&#34;&#34;
        return self.bounding_box().center()

    def edge_adjacent_to_vertices(self, v1, v2):
        for edge in v1.edges:
            if edge.v2 == v2 or edge.v1 == v2:
                return edge
        return None

    def face_adjacent_to_vertices(self, v1, v2):
        edge = v1.edge_adjacent_to_vertex(v2)
        if edge != None:
            if edge.v1 == v1:
                return edge.face1
            else:
                return edge.face2
        return None

    def add_vertex(self, x, y, z=0):
        v = Vertex(x,y,z)
        self.vertices.append(v)
        return v

    def add_face(self, vertices):
        f = Face(vertices)
        self.faces.append(f)
        return f

    def face_properties(self,face_analyse):
        values=[]
        for face in self.faces:
            values.append(face_analyse(face))
        return values

    def weld_vertices(self):
        weldedVertices = {}
        self.vertices = []
        for f in self.faces:
            for i in range(len(f.vertices)):
                v = f.vertices[i]
                vtuple = (v.x, v.y, v.z)
                if vtuple in weldedVertices:
                    f.vertices[i] = weldedVertices[vtuple]
                else:
                    weldedVertices[vtuple] = v
        self.vertices = [v for v in weldedVertices.values()]

    def update_edges(self):
        self.edges = []
        for v in self.vertices:
            v.edges = []
        for f in self.faces:
            v1 = f.vertices[-1]
            for v2 in f.vertices:
                edge = v1.edge_adjacent_to_vertex(v2)
                if edge == None:
                    edge = Edge(v1,v2)
                    v1.edges.append(edge)
                    v2.edges.append(edge)
                    self.edges.append(edge)
                if edge.v1 == v1:
                    edge.face1 = f
                else:
                    edge.face2 = f
                v1 = v2

    def update_topology(self):
        self.weld_vertices()
        self.update_edges()

    def copy(self):
        meshcopy = Mesh()

        # if mesh has no topolgy constructed
        if len(self.edges) == 0:
            for f in self.faces:
                vs = [Vertex(v.x,v.y,v.z) for v in f.vertices]
                for nv,ov in zip(vs, f.vertices):
                    nv.fix = ov.fix
                    nv.generation = ov.generation
                nf = meshcopy.add_face(vs)
                utils_face.face_copy_properties(f,nf)
        else:
            meshcopy.vertices = [Vertex(v.x,v.y,v.z) for v in self.vertices]
            for nv,ov in zip(meshcopy.vertices, self.vertices):
                nv.fix = ov.fix
                nv.generation = ov.generation

            for f in self.faces:
                vs = [meshcopy.vertices[self.vertices.index(v)] for v in f.vertices]
                nf = meshcopy.add_face(vs)
                utils_face.face_copy_properties(f,nf)
            
            for e in self.edges:
                iv1 = self.vertices.index(e.v1)
                iv2 = self.vertices.index(e.v1)
                ie1 = self.faces.index(e.face1)
                ie2 = self.faces.index(e.face2)
                v1c = meshcopy.vertices[iv1]
                v2c = meshcopy.vertices[iv2]
                edge = Edge(v1c,v2c)
                v1c.edges.append(edge)
                v2c.edges.append(edge)
                meshcopy.edges.append(edge)
                edge.face1 = meshcopy.faces[ie1]
                edge.face2 = meshcopy.faces[ie2]

        return meshcopy</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mola.Mesh.add_face"><code class="name flex">
<span>def <span class="ident">add_face</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_face(self, vertices):
    f = Face(vertices)
    self.faces.append(f)
    return f</code></pre>
</details>
</dd>
<dt id="mola.Mesh.add_vertex"><code class="name flex">
<span>def <span class="ident">add_vertex</span></span>(<span>self, x, y, z=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_vertex(self, x, y, z=0):
    v = Vertex(x,y,z)
    self.vertices.append(v)
    return v</code></pre>
</details>
</dd>
<dt id="mola.Mesh.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the bounding box of this mesh as a Box() object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_box(self):
    &#34;&#34;&#34;
    returns the bounding box of this mesh as a Box() object
    &#34;&#34;&#34;
    box = Box()
    for f in self.faces:
        for v in f.vertices:
            box.add_point(v.x,v.y,v.z)
    return box</code></pre>
</details>
</dd>
<dt id="mola.Mesh.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the center of the Mesh as a Vertex() object
Note: not the center of gravity, just the average of its vertices.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self):
    &#34;&#34;&#34;
    Returns the center of the Mesh as a Vertex() object
    Note: not the center of gravity, just the average of its vertices.
    &#34;&#34;&#34;
    return self.bounding_box().center()</code></pre>
</details>
</dd>
<dt id="mola.Mesh.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    meshcopy = Mesh()

    # if mesh has no topolgy constructed
    if len(self.edges) == 0:
        for f in self.faces:
            vs = [Vertex(v.x,v.y,v.z) for v in f.vertices]
            for nv,ov in zip(vs, f.vertices):
                nv.fix = ov.fix
                nv.generation = ov.generation
            nf = meshcopy.add_face(vs)
            utils_face.face_copy_properties(f,nf)
    else:
        meshcopy.vertices = [Vertex(v.x,v.y,v.z) for v in self.vertices]
        for nv,ov in zip(meshcopy.vertices, self.vertices):
            nv.fix = ov.fix
            nv.generation = ov.generation

        for f in self.faces:
            vs = [meshcopy.vertices[self.vertices.index(v)] for v in f.vertices]
            nf = meshcopy.add_face(vs)
            utils_face.face_copy_properties(f,nf)
        
        for e in self.edges:
            iv1 = self.vertices.index(e.v1)
            iv2 = self.vertices.index(e.v1)
            ie1 = self.faces.index(e.face1)
            ie2 = self.faces.index(e.face2)
            v1c = meshcopy.vertices[iv1]
            v2c = meshcopy.vertices[iv2]
            edge = Edge(v1c,v2c)
            v1c.edges.append(edge)
            v2c.edges.append(edge)
            meshcopy.edges.append(edge)
            edge.face1 = meshcopy.faces[ie1]
            edge.face2 = meshcopy.faces[ie2]

    return meshcopy</code></pre>
</details>
</dd>
<dt id="mola.Mesh.edge_adjacent_to_vertices"><code class="name flex">
<span>def <span class="ident">edge_adjacent_to_vertices</span></span>(<span>self, v1, v2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_adjacent_to_vertices(self, v1, v2):
    for edge in v1.edges:
        if edge.v2 == v2 or edge.v1 == v2:
            return edge
    return None</code></pre>
</details>
</dd>
<dt id="mola.Mesh.face_adjacent_to_vertices"><code class="name flex">
<span>def <span class="ident">face_adjacent_to_vertices</span></span>(<span>self, v1, v2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_adjacent_to_vertices(self, v1, v2):
    edge = v1.edge_adjacent_to_vertex(v2)
    if edge != None:
        if edge.v1 == v1:
            return edge.face1
        else:
            return edge.face2
    return None</code></pre>
</details>
</dd>
<dt id="mola.Mesh.face_properties"><code class="name flex">
<span>def <span class="ident">face_properties</span></span>(<span>self, face_analyse)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_properties(self,face_analyse):
    values=[]
    for face in self.faces:
        values.append(face_analyse(face))
    return values</code></pre>
</details>
</dd>
<dt id="mola.Mesh.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, sx, sy, sz)</span>
</code></dt>
<dd>
<section class="desc"><p>scales a mesh by adding multiplying
the position of its vertices by sx, sy and sz.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, sx, sy, sz):
    &#34;&#34;&#34;
    scales a mesh by adding multiplying
    the position of its vertices by sx, sy and sz.
    &#34;&#34;&#34;
    #vs = Vertex(sx, sy, sz)
    for v in self.vertices:
        v.x *= sx
        v.y *= sy
        v.z *= sz</code></pre>
</details>
</dd>
<dt id="mola.Mesh.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, tx, ty, tz)</span>
</code></dt>
<dd>
<section class="desc"><p>translates a mesh by adding tx,ty and tz
to the position of the vertices.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate(self, tx, ty, tz):
    &#34;&#34;&#34;
    translates a mesh by adding tx,ty and tz
    to the position of the vertices.
    &#34;&#34;&#34;
    vt = Vertex(tx, ty, tz)
    for v in self.vertices:
        v.add(vt)</code></pre>
</details>
</dd>
<dt id="mola.Mesh.update_edges"><code class="name flex">
<span>def <span class="ident">update_edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_edges(self):
    self.edges = []
    for v in self.vertices:
        v.edges = []
    for f in self.faces:
        v1 = f.vertices[-1]
        for v2 in f.vertices:
            edge = v1.edge_adjacent_to_vertex(v2)
            if edge == None:
                edge = Edge(v1,v2)
                v1.edges.append(edge)
                v2.edges.append(edge)
                self.edges.append(edge)
            if edge.v1 == v1:
                edge.face1 = f
            else:
                edge.face2 = f
            v1 = v2</code></pre>
</details>
</dd>
<dt id="mola.Mesh.update_topology"><code class="name flex">
<span>def <span class="ident">update_topology</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_topology(self):
    self.weld_vertices()
    self.update_edges()</code></pre>
</details>
</dd>
<dt id="mola.Mesh.weld_vertices"><code class="name flex">
<span>def <span class="ident">weld_vertices</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weld_vertices(self):
    weldedVertices = {}
    self.vertices = []
    for f in self.faces:
        for i in range(len(f.vertices)):
            v = f.vertices[i]
            vtuple = (v.x, v.y, v.z)
            if vtuple in weldedVertices:
                f.vertices[i] = weldedVertices[vtuple]
            else:
                weldedVertices[vtuple] = v
    self.vertices = [v for v in weldedVertices.values()]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mola.PriorityQueue"><code class="flex name class">
<span>class <span class="ident">PriorityQueue</span></span>
<span>(</span><span>maxsize=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Variant of Queue that retrieves open entries in priority order (lowest first).</p>
<p>Entries are typically tuples of the form:
(priority number, data).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PriorityQueue(Queue):
    &#39;&#39;&#39;Variant of Queue that retrieves open entries in priority order (lowest first).

    Entries are typically tuples of the form:  (priority number, data).
    &#39;&#39;&#39;

    def _init(self, maxsize):
        self.queue = []

    def _qsize(self):
        return len(self.queue)

    def _put(self, item):
        heappush(self.queue, item)

    def _get(self):
        return heappop(self.queue)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>queue.Queue</li>
</ul>
</dd>
<dt id="mola.SinusFunction"><code class="flex name class">
<span>class <span class="ident">SinusFunction</span></span>
<span>(</span><span>frequency, amplitude=1, phase=0, offset=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SinusFunction(object):
    def __init__(self, frequency, amplitude=1, phase=0, offset=0):
        self.frequency = frequency
        self.amplitude = amplitude
        self.phase = phase
        self.offset = offset

    def getValue(self,value):
        return math.sin(self.frequency * value + self.phase) * self.amplitude + self.offset</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mola.SinusFunction.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValue(self,value):
    return math.sin(self.frequency * value + self.phase) * self.amplitude + self.offset</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mola.Vertex"><code class="flex name class">
<span>class <span class="ident">Vertex</span></span>
<span>(</span><span>x=0, y=0, z=0)</span>
</code></dt>
<dd>
<section class="desc"><p>A Vertex defines a point in space.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong>, <strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>The coordinates of the <a title="mola.Vertex" href="#mola.Vertex"><code>Vertex</code></a>.</dd>
<dt><strong><code>fix</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Flag to set a Vertex to be fixed or not.</dd>
<dt><strong><code>generation</code></strong> :&ensp;<code>integer</code></dt>
<dd>Number in what generation of subdivision the face was created.</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>list</code></dt>
<dd>List of edges connected to the <a title="mola.Vertex" href="#mola.Vertex"><code>Vertex</code></a>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vertex:
    &#34;&#34;&#34;A Vertex defines a point in space.

    Attributes
    ----------
    x, y, z : float
        The coordinates of the `Vertex`.
    fix : boolean
        Flag to set a Vertex to be fixed or not.
    generation : integer
        Number in what generation of subdivision the face was created.
    edges : list
        List of edges connected to the `Vertex`.
    &#34;&#34;&#34;
    def __init__(self, x=0, y=0, z=0):
        self.x = x
        self.y = y
        self.z = z
        self.fix = False
        self.generation = 0
        self.edges = []

    def __str__(self):
        &#34;&#34;&#34;
        Returns a string representation of the Vertex (&#34;x.xx y.yy z.zz&#34;)
        &#34;&#34;&#34;
        return &#39; &#39;.join([str(v) for v in [self.x,self.y,self.z]])

    def __repr__(self):
        return &#39;Vertex(&#39;+&#39;,&#39;.join([str(v) for v in [self.x,self.y,self.z]])+&#39;)&#39;

    def __eq__(self, other):
        &#34;&#34;&#34;
        Compares this `Vertex` to another `Vertex`. Returns true if all their 3 coordinates are equal.
        &#34;&#34;&#34;
        if isinstance(other, self.__class__):
            return (self.x == other.x) and (self.y == other.y) and (self.z == other.z)
        else:
            return False

    def edge_adjacent_to_vertex(self, v):
        &#34;&#34;&#34;
        Returns the edge connecting this `Vertex` to another `Vertex` or `None` if there&#39;s none.

        Arguments:
        ----------
        v : mola.Vertex
            The other Vertex
        &#34;&#34;&#34;
        for edge in self.edges:
            if edge.v2 is v or edge.v1 is v:
                return edge
        return None

    def add(self, vertex):
        &#34;&#34;&#34;
        adds the position vector of another Vertex to
        the position vector of this Vertex.
        &#34;&#34;&#34;
        self.x += vertex.x
        self.y += vertex.y
        self.z += vertex.z
        return self

    def subtract(self, vertex):
        &#34;&#34;&#34;
        subtracts the position vector of another Vertex from
        the position vector of this Vertex.
        &#34;&#34;&#34;
        self.x -= vertex.x
        self.y -= vertex.y
        self.z -= vertex.z
        return self

    def scale(self, factor):
        &#34;&#34;&#34;
        scales the position vector of this Vertex
        by a factor (multiplication).
        &#34;&#34;&#34;
        self.x *= factor
        self.y *= factor
        self.z *= factor
        return self

    def divide(self, factor):
        &#34;&#34;&#34;
        scales the position vector of this Vertex
        by a factor (division).
        &#34;&#34;&#34;
        self.x /= factor
        self.y /= factor
        self.z /= factor
        return self

    def length(self):
        &#34;&#34;&#34;
        returns the length of the position vector,
        the distance from the origin (0,0,0).
        &#34;&#34;&#34;
        return math.sqrt(self.x**2 + self.y**2 + self.z**2)

    def unitize(self):
        &#34;&#34;&#34;
        returns a vector of the same direction
        but of unit length 1
        &#34;&#34;&#34;
        l = self.length()
        if l==0: return self
        return self.divide(l)

    def __add__(self, other):
        vector = Vertex(self.x, self.y, self.z)
        return vector.add(other)

    def __sub__(self, other):
        vector = Vertex(self.x, self.y, self.z)
        return vector.subtract(other)

    def __mul__(self, factor):
        vector = Vertex(self.x, self.y, self.z)
        return vector.scale(factor)

    # for python 3
    def __truediv__(self, factor):
        vector = Vertex(self.x, self.y, self.z)
        return vector.divide(factor)

    # for python 2
    def __div__(self, factor):
        vector = Vertex(self.x, self.y, self.z)
        return vector.divide(factor)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mola.Vertex.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, vertex)</span>
</code></dt>
<dd>
<section class="desc"><p>adds the position vector of another Vertex to
the position vector of this Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, vertex):
    &#34;&#34;&#34;
    adds the position vector of another Vertex to
    the position vector of this Vertex.
    &#34;&#34;&#34;
    self.x += vertex.x
    self.y += vertex.y
    self.z += vertex.z
    return self</code></pre>
</details>
</dd>
<dt id="mola.Vertex.divide"><code class="name flex">
<span>def <span class="ident">divide</span></span>(<span>self, factor)</span>
</code></dt>
<dd>
<section class="desc"><p>scales the position vector of this Vertex
by a factor (division).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide(self, factor):
    &#34;&#34;&#34;
    scales the position vector of this Vertex
    by a factor (division).
    &#34;&#34;&#34;
    self.x /= factor
    self.y /= factor
    self.z /= factor
    return self</code></pre>
</details>
</dd>
<dt id="mola.Vertex.edge_adjacent_to_vertex"><code class="name flex">
<span>def <span class="ident">edge_adjacent_to_vertex</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the edge connecting this <a title="mola.Vertex" href="#mola.Vertex"><code>Vertex</code></a> to another <a title="mola.Vertex" href="#mola.Vertex"><code>Vertex</code></a> or <code>None</code> if there's none.</p>
<h2 id="arguments">Arguments:</h2>
<p>v : mola.Vertex
The other Vertex</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_adjacent_to_vertex(self, v):
    &#34;&#34;&#34;
    Returns the edge connecting this `Vertex` to another `Vertex` or `None` if there&#39;s none.

    Arguments:
    ----------
    v : mola.Vertex
        The other Vertex
    &#34;&#34;&#34;
    for edge in self.edges:
        if edge.v2 is v or edge.v1 is v:
            return edge
    return None</code></pre>
</details>
</dd>
<dt id="mola.Vertex.length"><code class="name flex">
<span>def <span class="ident">length</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the length of the position vector,
the distance from the origin (0,0,0).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length(self):
    &#34;&#34;&#34;
    returns the length of the position vector,
    the distance from the origin (0,0,0).
    &#34;&#34;&#34;
    return math.sqrt(self.x**2 + self.y**2 + self.z**2)</code></pre>
</details>
</dd>
<dt id="mola.Vertex.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, factor)</span>
</code></dt>
<dd>
<section class="desc"><p>scales the position vector of this Vertex
by a factor (multiplication).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, factor):
    &#34;&#34;&#34;
    scales the position vector of this Vertex
    by a factor (multiplication).
    &#34;&#34;&#34;
    self.x *= factor
    self.y *= factor
    self.z *= factor
    return self</code></pre>
</details>
</dd>
<dt id="mola.Vertex.subtract"><code class="name flex">
<span>def <span class="ident">subtract</span></span>(<span>self, vertex)</span>
</code></dt>
<dd>
<section class="desc"><p>subtracts the position vector of another Vertex from
the position vector of this Vertex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtract(self, vertex):
    &#34;&#34;&#34;
    subtracts the position vector of another Vertex from
    the position vector of this Vertex.
    &#34;&#34;&#34;
    self.x -= vertex.x
    self.y -= vertex.y
    self.z -= vertex.z
    return self</code></pre>
</details>
</dd>
<dt id="mola.Vertex.unitize"><code class="name flex">
<span>def <span class="ident">unitize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>returns a vector of the same direction
but of unit length 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unitize(self):
    &#34;&#34;&#34;
    returns a vector of the same direction
    but of unit length 1
    &#34;&#34;&#34;
    l = self.length()
    if l==0: return self
    return self.divide(l)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="mola.colab2D" href="colab2D.html">mola.colab2D</a></code></li>
<li><code><a title="mola.colab3D" href="colab3D.html">mola.colab3D</a></code></li>
<li><code><a title="mola.core_box" href="core_box.html">mola.core_box</a></code></li>
<li><code><a title="mola.core_edge" href="core_edge.html">mola.core_edge</a></code></li>
<li><code><a title="mola.core_face" href="core_face.html">mola.core_face</a></code></li>
<li><code><a title="mola.core_grid" href="core_grid.html">mola.core_grid</a></code></li>
<li><code><a title="mola.core_mesh" href="core_mesh.html">mola.core_mesh</a></code></li>
<li><code><a title="mola.core_vertex" href="core_vertex.html">mola.core_vertex</a></code></li>
<li><code><a title="mola.graph" href="graph.html">mola.graph</a></code></li>
<li><code><a title="mola.grid_factory" href="grid_factory.html">mola.grid_factory</a></code></li>
<li><code><a title="mola.io" href="io.html">mola.io</a></code></li>
<li><code><a title="mola.mesh_factory" href="mesh_factory.html">mola.mesh_factory</a></code></li>
<li><code><a title="mola.mesh_marching_cubes" href="mesh_marching_cubes.html">mola.mesh_marching_cubes</a></code></li>
<li><code><a title="mola.mesh_subdivision" href="mesh_subdivision.html">mola.mesh_subdivision</a></code></li>
<li><code><a title="mola.module_blender" href="module_blender.html">mola.module_blender</a></code></li>
<li><code><a title="mola.module_compas" href="module_compas.html">mola.module_compas</a></code></li>
<li><code><a title="mola.module_processing" href="module_processing.html">mola.module_processing</a></code></li>
<li><code><a title="mola.module_rhino" href="module_rhino.html">mola.module_rhino</a></code></li>
<li><code><a title="mola.slicer" href="slicer.html">mola.slicer</a></code></li>
<li><code><a title="mola.utils_color" href="utils_color.html">mola.utils_color</a></code></li>
<li><code><a title="mola.utils_face" href="utils_face.html">mola.utils_face</a></code></li>
<li><code><a title="mola.utils_math" href="utils_math.html">mola.utils_math</a></code></li>
<li><code><a title="mola.utils_mesh" href="utils_mesh.html">mola.utils_mesh</a></code></li>
<li><code><a title="mola.utils_poly" href="utils_poly.html">mola.utils_poly</a></code></li>
<li><code><a title="mola.utils_vertex" href="utils_vertex.html">mola.utils_vertex</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mola.color_faces_by_area" href="#mola.color_faces_by_area">color_faces_by_area</a></code></li>
<li><code><a title="mola.color_faces_by_compactness" href="#mola.color_faces_by_compactness">color_faces_by_compactness</a></code></li>
<li><code><a title="mola.color_faces_by_curvature" href="#mola.color_faces_by_curvature">color_faces_by_curvature</a></code></li>
<li><code><a title="mola.color_faces_by_function" href="#mola.color_faces_by_function">color_faces_by_function</a></code></li>
<li><code><a title="mola.color_faces_by_horizontal_angle" href="#mola.color_faces_by_horizontal_angle">color_faces_by_horizontal_angle</a></code></li>
<li><code><a title="mola.color_faces_by_map" href="#mola.color_faces_by_map">color_faces_by_map</a></code></li>
<li><code><a title="mola.color_faces_by_perimeter" href="#mola.color_faces_by_perimeter">color_faces_by_perimeter</a></code></li>
<li><code><a title="mola.color_faces_by_vertical_angle" href="#mola.color_faces_by_vertical_angle">color_faces_by_vertical_angle</a></code></li>
<li><code><a title="mola.color_hue_to_rgb" href="#mola.color_hue_to_rgb">color_hue_to_rgb</a></code></li>
<li><code><a title="mola.color_map" href="#mola.color_map">color_map</a></code></li>
<li><code><a title="mola.construct_box" href="#mola.construct_box">construct_box</a></code></li>
<li><code><a title="mola.construct_circle" href="#mola.construct_circle">construct_circle</a></code></li>
<li><code><a title="mola.construct_cone" href="#mola.construct_cone">construct_cone</a></code></li>
<li><code><a title="mola.construct_dodecahedron" href="#mola.construct_dodecahedron">construct_dodecahedron</a></code></li>
<li><code><a title="mola.construct_icosahedron" href="#mola.construct_icosahedron">construct_icosahedron</a></code></li>
<li><code><a title="mola.construct_octahedron" href="#mola.construct_octahedron">construct_octahedron</a></code></li>
<li><code><a title="mola.construct_rhombic_dodecahedron" href="#mola.construct_rhombic_dodecahedron">construct_rhombic_dodecahedron</a></code></li>
<li><code><a title="mola.construct_single_face" href="#mola.construct_single_face">construct_single_face</a></code></li>
<li><code><a title="mola.construct_tetrahedron" href="#mola.construct_tetrahedron">construct_tetrahedron</a></code></li>
<li><code><a title="mola.construct_torus" href="#mola.construct_torus">construct_torus</a></code></li>
<li><code><a title="mola.export_obj" href="#mola.export_obj">export_obj</a></code></li>
<li><code><a title="mola.export_obj_faces" href="#mola.export_obj_faces">export_obj_faces</a></code></li>
<li><code><a title="mola.face_angle_horizontal" href="#mola.face_angle_horizontal">face_angle_horizontal</a></code></li>
<li><code><a title="mola.face_angle_vertical" href="#mola.face_angle_vertical">face_angle_vertical</a></code></li>
<li><code><a title="mola.face_area" href="#mola.face_area">face_area</a></code></li>
<li><code><a title="mola.face_center" href="#mola.face_center">face_center</a></code></li>
<li><code><a title="mola.face_compactness" href="#mola.face_compactness">face_compactness</a></code></li>
<li><code><a title="mola.face_copy_properties" href="#mola.face_copy_properties">face_copy_properties</a></code></li>
<li><code><a title="mola.face_curvature" href="#mola.face_curvature">face_curvature</a></code></li>
<li><code><a title="mola.face_normal" href="#mola.face_normal">face_normal</a></code></li>
<li><code><a title="mola.face_perimeter" href="#mola.face_perimeter">face_perimeter</a></code></li>
<li><code><a title="mola.face_scale" href="#mola.face_scale">face_scale</a></code></li>
<li><code><a title="mola.floor" href="#mola.floor">floor</a></code></li>
<li><code><a title="mola.grid_set_values_at_borders" href="#mola.grid_set_values_at_borders">grid_set_values_at_borders</a></code></li>
<li><code><a title="mola.grid_set_values_sinusoids" href="#mola.grid_set_values_sinusoids">grid_set_values_sinusoids</a></code></li>
<li><code><a title="mola.import_obj" href="#mola.import_obj">import_obj</a></code></li>
<li><code><a title="mola.import_obj_faces" href="#mola.import_obj_faces">import_obj_faces</a></code></li>
<li><code><a title="mola.marching_cubes" href="#mola.marching_cubes">marching_cubes</a></code></li>
<li><code><a title="mola.marching_cubes_from_grid" href="#mola.marching_cubes_from_grid">marching_cubes_from_grid</a></code></li>
<li><code><a title="mola.math_determinant" href="#mola.math_determinant">math_determinant</a></code></li>
<li><code><a title="mola.math_map" href="#mola.math_map">math_map</a></code></li>
<li><code><a title="mola.math_map_list" href="#mola.math_map_list">math_map_list</a></code></li>
<li><code><a title="mola.mesh_smooth_laplacian" href="#mola.mesh_smooth_laplacian">mesh_smooth_laplacian</a></code></li>
<li><code><a title="mola.normal_edge_2d" href="#mola.normal_edge_2d">normal_edge_2d</a></code></li>
<li><code><a title="mola.normal_edge_2d_non_unified" href="#mola.normal_edge_2d_non_unified">normal_edge_2d_non_unified</a></code></li>
<li><code><a title="mola.normal_vertex_2d" href="#mola.normal_vertex_2d">normal_vertex_2d</a></code></li>
<li><code><a title="mola.offset" href="#mola.offset">offset</a></code></li>
<li><code><a title="mola.slice" href="#mola.slice">slice</a></code></li>
<li><code><a title="mola.sliceTriangle" href="#mola.sliceTriangle">sliceTriangle</a></code></li>
<li><code><a title="mola.sliceWithZ" href="#mola.sliceWithZ">sliceWithZ</a></code></li>
<li><code><a title="mola.subdivide_catmull_2d" href="#mola.subdivide_catmull_2d">subdivide_catmull_2d</a></code></li>
<li><code><a title="mola.subdivide_custom_triface_extrude_tapered_nonU" href="#mola.subdivide_custom_triface_extrude_tapered_nonU">subdivide_custom_triface_extrude_tapered_nonU</a></code></li>
<li><code><a title="mola.subdivide_face_extrude" href="#mola.subdivide_face_extrude">subdivide_face_extrude</a></code></li>
<li><code><a title="mola.subdivide_face_extrude_tapered" href="#mola.subdivide_face_extrude_tapered">subdivide_face_extrude_tapered</a></code></li>
<li><code><a title="mola.subdivide_face_extrude_to_point" href="#mola.subdivide_face_extrude_to_point">subdivide_face_extrude_to_point</a></code></li>
<li><code><a title="mola.subdivide_face_extrude_to_point_center" href="#mola.subdivide_face_extrude_to_point_center">subdivide_face_extrude_to_point_center</a></code></li>
<li><code><a title="mola.subdivide_face_offset_planar" href="#mola.subdivide_face_offset_planar">subdivide_face_offset_planar</a></code></li>
<li><code><a title="mola.subdivide_face_split_frame" href="#mola.subdivide_face_split_frame">subdivide_face_split_frame</a></code></li>
<li><code><a title="mola.subdivide_face_split_grid" href="#mola.subdivide_face_split_grid">subdivide_face_split_grid</a></code></li>
<li><code><a title="mola.subdivide_face_split_offset" href="#mola.subdivide_face_split_offset">subdivide_face_split_offset</a></code></li>
<li><code><a title="mola.subdivide_face_split_offsets" href="#mola.subdivide_face_split_offsets">subdivide_face_split_offsets</a></code></li>
<li><code><a title="mola.subdivide_face_split_rel" href="#mola.subdivide_face_split_rel">subdivide_face_split_rel</a></code></li>
<li><code><a title="mola.subdivide_face_split_rel_free_quad" href="#mola.subdivide_face_split_rel_free_quad">subdivide_face_split_rel_free_quad</a></code></li>
<li><code><a title="mola.subdivide_face_split_rel_multiple" href="#mola.subdivide_face_split_rel_multiple">subdivide_face_split_rel_multiple</a></code></li>
<li><code><a title="mola.subdivide_face_split_roof" href="#mola.subdivide_face_split_roof">subdivide_face_split_roof</a></code></li>
<li><code><a title="mola.subdivide_mesh" href="#mola.subdivide_mesh">subdivide_mesh</a></code></li>
<li><code><a title="mola.subdivide_mesh_catmull" href="#mola.subdivide_mesh_catmull">subdivide_mesh_catmull</a></code></li>
<li><code><a title="mola.subdivide_mesh_extrude_tapered" href="#mola.subdivide_mesh_extrude_tapered">subdivide_mesh_extrude_tapered</a></code></li>
<li><code><a title="mola.subdivide_mesh_extrude_to_point_center" href="#mola.subdivide_mesh_extrude_to_point_center">subdivide_mesh_extrude_to_point_center</a></code></li>
<li><code><a title="mola.triangle_area" href="#mola.triangle_area">triangle_area</a></code></li>
<li><code><a title="mola.triangle_coords_area" href="#mola.triangle_coords_area">triangle_coords_area</a></code></li>
<li><code><a title="mola.triangle_normal" href="#mola.triangle_normal">triangle_normal</a></code></li>
<li><code><a title="mola.vertex_add" href="#mola.vertex_add">vertex_add</a></code></li>
<li><code><a title="mola.vertex_angle" href="#mola.vertex_angle">vertex_angle</a></code></li>
<li><code><a title="mola.vertex_angle_triangle" href="#mola.vertex_angle_triangle">vertex_angle_triangle</a></code></li>
<li><code><a title="mola.vertex_between_abs" href="#mola.vertex_between_abs">vertex_between_abs</a></code></li>
<li><code><a title="mola.vertex_between_rel" href="#mola.vertex_between_rel">vertex_between_rel</a></code></li>
<li><code><a title="mola.vertex_center" href="#mola.vertex_center">vertex_center</a></code></li>
<li><code><a title="mola.vertex_cross" href="#mola.vertex_cross">vertex_cross</a></code></li>
<li><code><a title="mola.vertex_distance" href="#mola.vertex_distance">vertex_distance</a></code></li>
<li><code><a title="mola.vertex_divide" href="#mola.vertex_divide">vertex_divide</a></code></li>
<li><code><a title="mola.vertex_dot" href="#mola.vertex_dot">vertex_dot</a></code></li>
<li><code><a title="mola.vertex_length" href="#mola.vertex_length">vertex_length</a></code></li>
<li><code><a title="mola.vertex_line_line_intersection" href="#mola.vertex_line_line_intersection">vertex_line_line_intersection</a></code></li>
<li><code><a title="mola.vertex_offset_line" href="#mola.vertex_offset_line">vertex_offset_line</a></code></li>
<li><code><a title="mola.vertex_offset_point" href="#mola.vertex_offset_point">vertex_offset_point</a></code></li>
<li><code><a title="mola.vertex_rotate_2D_90" href="#mola.vertex_rotate_2D_90">vertex_rotate_2D_90</a></code></li>
<li><code><a title="mola.vertex_scale" href="#mola.vertex_scale">vertex_scale</a></code></li>
<li><code><a title="mola.vertex_subtract" href="#mola.vertex_subtract">vertex_subtract</a></code></li>
<li><code><a title="mola.vertex_unitize" href="#mola.vertex_unitize">vertex_unitize</a></code></li>
<li><code><a title="mola.vertices_list_area" href="#mola.vertices_list_area">vertices_list_area</a></code></li>
<li><code><a title="mola.vertices_list_center" href="#mola.vertices_list_center">vertices_list_center</a></code></li>
<li><code><a title="mola.vertices_list_normal" href="#mola.vertices_list_normal">vertices_list_normal</a></code></li>
<li><code><a title="mola.weldVertices" href="#mola.weldVertices">weldVertices</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mola.Box" href="#mola.Box">Box</a></code></h4>
<ul class="">
<li><code><a title="mola.Box.add_point" href="#mola.Box.add_point">add_point</a></code></li>
<li><code><a title="mola.Box.center" href="#mola.Box.center">center</a></code></li>
<li><code><a title="mola.Box.dim_x" href="#mola.Box.dim_x">dim_x</a></code></li>
<li><code><a title="mola.Box.dim_y" href="#mola.Box.dim_y">dim_y</a></code></li>
<li><code><a title="mola.Box.dim_z" href="#mola.Box.dim_z">dim_z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.Edge" href="#mola.Edge">Edge</a></code></h4>
<ul class="">
<li><code><a title="mola.Edge.center" href="#mola.Edge.center">center</a></code></li>
<li><code><a title="mola.Edge.other_vertex" href="#mola.Edge.other_vertex">other_vertex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.Face" href="#mola.Face">Face</a></code></h4>
<ul class="two-column">
<li><code><a title="mola.Face.angle_horizontal" href="#mola.Face.angle_horizontal">angle_horizontal</a></code></li>
<li><code><a title="mola.Face.angle_vertical" href="#mola.Face.angle_vertical">angle_vertical</a></code></li>
<li><code><a title="mola.Face.area" href="#mola.Face.area">area</a></code></li>
<li><code><a title="mola.Face.center" href="#mola.Face.center">center</a></code></li>
<li><code><a title="mola.Face.compactness" href="#mola.Face.compactness">compactness</a></code></li>
<li><code><a title="mola.Face.curvature" href="#mola.Face.curvature">curvature</a></code></li>
<li><code><a title="mola.Face.normal" href="#mola.Face.normal">normal</a></code></li>
<li><code><a title="mola.Face.perimeter" href="#mola.Face.perimeter">perimeter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.Graph" href="#mola.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="mola.Graph.from_grid_2d" href="#mola.Graph.from_grid_2d">from_grid_2d</a></code></li>
<li><code><a title="mola.Graph.from_grid_3d" href="#mola.Graph.from_grid_3d">from_grid_3d</a></code></li>
<li><code><a title="mola.Graph.from_hex_grid_2d" href="#mola.Graph.from_hex_grid_2d">from_hex_grid_2d</a></code></li>
<li><code><a title="mola.Graph.from_mesh_edges" href="#mola.Graph.from_mesh_edges">from_mesh_edges</a></code></li>
<li><code><a title="mola.Graph.from_mesh_faces" href="#mola.Graph.from_mesh_faces">from_mesh_faces</a></code></li>
<li><code><a title="mola.Graph.from_mesh_vertices" href="#mola.Graph.from_mesh_vertices">from_mesh_vertices</a></code></li>
<li><code><a title="mola.Graph.get_neighbours" href="#mola.Graph.get_neighbours">get_neighbours</a></code></li>
<li><code><a title="mola.Graph.size" href="#mola.Graph.size">size</a></code></li>
<li><code><a title="mola.Graph.weight" href="#mola.Graph.weight">weight</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.GraphAnalyser" href="#mola.GraphAnalyser">GraphAnalyser</a></code></h4>
<ul class="">
<li><code><a title="mola.GraphAnalyser.compute_distance_to_nodes" href="#mola.GraphAnalyser.compute_distance_to_nodes">compute_distance_to_nodes</a></code></li>
<li><code><a title="mola.GraphAnalyser.compute_traffic_and_centrality" href="#mola.GraphAnalyser.compute_traffic_and_centrality">compute_traffic_and_centrality</a></code></li>
<li><code><a title="mola.GraphAnalyser.shortest_path" href="#mola.GraphAnalyser.shortest_path">shortest_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.Grid" href="#mola.Grid">Grid</a></code></h4>
<ul class="two-column">
<li><code><a title="mola.Grid.get_value_at_index" href="#mola.Grid.get_value_at_index">get_value_at_index</a></code></li>
<li><code><a title="mola.Grid.get_value_at_xyz" href="#mola.Grid.get_value_at_xyz">get_value_at_xyz</a></code></li>
<li><code><a title="mola.Grid.quad_mesh" href="#mola.Grid.quad_mesh">quad_mesh</a></code></li>
<li><code><a title="mola.Grid.set_value_at_index" href="#mola.Grid.set_value_at_index">set_value_at_index</a></code></li>
<li><code><a title="mola.Grid.set_value_at_xyz" href="#mola.Grid.set_value_at_xyz">set_value_at_xyz</a></code></li>
<li><code><a title="mola.Grid.shortest_path" href="#mola.Grid.shortest_path">shortest_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.GridManager" href="#mola.GridManager">GridManager</a></code></h4>
<ul class="">
<li><code><a title="mola.GridManager.get_index" href="#mola.GridManager.get_index">get_index</a></code></li>
<li><code><a title="mola.GridManager.get_neighbors_2d" href="#mola.GridManager.get_neighbors_2d">get_neighbors_2d</a></code></li>
<li><code><a title="mola.GridManager.get_neighbors_3d" href="#mola.GridManager.get_neighbors_3d">get_neighbors_3d</a></code></li>
<li><code><a title="mola.GridManager.get_neighbors_hex_2d" href="#mola.GridManager.get_neighbors_hex_2d">get_neighbors_hex_2d</a></code></li>
<li><code><a title="mola.GridManager.get_x" href="#mola.GridManager.get_x">get_x</a></code></li>
<li><code><a title="mola.GridManager.get_y" href="#mola.GridManager.get_y">get_y</a></code></li>
<li><code><a title="mola.GridManager.get_z" href="#mola.GridManager.get_z">get_z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.HexGrid" href="#mola.HexGrid">HexGrid</a></code></h4>
<ul class="">
<li><code><a title="mola.HexGrid.get_position" href="#mola.HexGrid.get_position">get_position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.Mesh" href="#mola.Mesh">Mesh</a></code></h4>
<ul class="">
<li><code><a title="mola.Mesh.add_face" href="#mola.Mesh.add_face">add_face</a></code></li>
<li><code><a title="mola.Mesh.add_vertex" href="#mola.Mesh.add_vertex">add_vertex</a></code></li>
<li><code><a title="mola.Mesh.bounding_box" href="#mola.Mesh.bounding_box">bounding_box</a></code></li>
<li><code><a title="mola.Mesh.center" href="#mola.Mesh.center">center</a></code></li>
<li><code><a title="mola.Mesh.copy" href="#mola.Mesh.copy">copy</a></code></li>
<li><code><a title="mola.Mesh.edge_adjacent_to_vertices" href="#mola.Mesh.edge_adjacent_to_vertices">edge_adjacent_to_vertices</a></code></li>
<li><code><a title="mola.Mesh.face_adjacent_to_vertices" href="#mola.Mesh.face_adjacent_to_vertices">face_adjacent_to_vertices</a></code></li>
<li><code><a title="mola.Mesh.face_properties" href="#mola.Mesh.face_properties">face_properties</a></code></li>
<li><code><a title="mola.Mesh.scale" href="#mola.Mesh.scale">scale</a></code></li>
<li><code><a title="mola.Mesh.translate" href="#mola.Mesh.translate">translate</a></code></li>
<li><code><a title="mola.Mesh.update_edges" href="#mola.Mesh.update_edges">update_edges</a></code></li>
<li><code><a title="mola.Mesh.update_topology" href="#mola.Mesh.update_topology">update_topology</a></code></li>
<li><code><a title="mola.Mesh.weld_vertices" href="#mola.Mesh.weld_vertices">weld_vertices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.PriorityQueue" href="#mola.PriorityQueue">PriorityQueue</a></code></h4>
</li>
<li>
<h4><code><a title="mola.SinusFunction" href="#mola.SinusFunction">SinusFunction</a></code></h4>
<ul class="">
<li><code><a title="mola.SinusFunction.getValue" href="#mola.SinusFunction.getValue">getValue</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mola.Vertex" href="#mola.Vertex">Vertex</a></code></h4>
<ul class="">
<li><code><a title="mola.Vertex.add" href="#mola.Vertex.add">add</a></code></li>
<li><code><a title="mola.Vertex.divide" href="#mola.Vertex.divide">divide</a></code></li>
<li><code><a title="mola.Vertex.edge_adjacent_to_vertex" href="#mola.Vertex.edge_adjacent_to_vertex">edge_adjacent_to_vertex</a></code></li>
<li><code><a title="mola.Vertex.length" href="#mola.Vertex.length">length</a></code></li>
<li><code><a title="mola.Vertex.scale" href="#mola.Vertex.scale">scale</a></code></li>
<li><code><a title="mola.Vertex.subtract" href="#mola.Vertex.subtract">subtract</a></code></li>
<li><code><a title="mola.Vertex.unitize" href="#mola.Vertex.unitize">unitize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>